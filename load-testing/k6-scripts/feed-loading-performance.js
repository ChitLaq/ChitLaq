/**
 * ChitLaq M1 MVP - Feed Loading Performance Load Test
 * Generated by PROMPT 1.6 - Performance Optimization & Load Testing Framework
 * Senior Performance Engineer - 15+ years application optimization and load testing experience
 * 
 * Load test for feed loading performance with 500 concurrent users
 * Tests: Feed pagination, content loading, caching effectiveness, database performance
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter, Gauge } from 'k6/metrics';
import { SharedArray } from 'k6/data';

// Custom metrics
const feedLoadRate = new Rate('feed_load_success_rate');
const feedLoadTime = new Trend('feed_load_response_time');
const feedPaginationTime = new Trend('feed_pagination_time');
const feedCacheHitRate = new Gauge('feed_cache_hit_rate');
const feedContentSize = new Trend('feed_content_size');
const errorCounter = new Counter('feed_load_errors');

// Test configuration
export const options = {
  stages: [
    { duration: '3m', target: 50 },    // Ramp up to 50 users
    { duration: '5m', target: 200 },   // Ramp up to 200 users
    { duration: '5m', target: 500 },   // Ramp up to 500 users
    { duration: '15m', target: 500 },  // Stay at 500 users
    { duration: '3m', target: 0 },    // Ramp down to 0 users
  ],
  thresholds: {
    'feed_load_success_rate': ['rate>0.98'], // 98% success rate
    'feed_load_response_time': ['p(95)<200'], // 95% under 200ms
    'feed_pagination_time': ['p(95)<150'], // 95% under 150ms
    'feed_content_size': ['p(95)<50000'], // 95% under 50KB
    'http_req_duration': ['p(95)<250'], // 95% under 250ms
    'http_req_failed': ['rate<0.02'], // Less than 2% failures
  },
};

// Test data for different feed scenarios
const feedTypes = new SharedArray('feedTypes', function () {
  return [
    { type: 'following', endpoint: '/api/feed/following' },
    { type: 'explore', endpoint: '/api/feed/explore' },
    { type: 'trending', endpoint: '/api/feed/trending' },
    { type: 'recommended', endpoint: '/api/feed/recommended' }
  ];
});

const pageSizes = new SharedArray('pageSizes', function () {
  return [10, 20, 50, 100];
});

// Authentication tokens for different user types
const authTokens = new SharedArray('authTokens', function () {
  // These would be pre-generated test user tokens
  return [
    'test_token_user_1',
    'test_token_user_2',
    'test_token_user_3',
    'test_token_user_4',
    'test_token_user_5'
  ];
});

// Generate random user session
function getRandomUser() {
  return {
    token: authTokens[Math.floor(Math.random() * authTokens.length)],
    userId: Math.floor(Math.random() * 1000) + 1
  };
}

// Load feed with different parameters
function loadFeed(feedType, page = 1, limit = 20, user) {
  const startTime = Date.now();
  
  const params = {
    page: page,
    limit: limit,
    sort: Math.random() > 0.5 ? 'recent' : 'popular',
    include_metadata: 'true'
  };
  
  const queryString = Object.keys(params)
    .map(key => `${key}=${encodeURIComponent(params[key])}`)
    .join('&');
  
  const response = http.get(`${__ENV.BASE_URL}${feedType.endpoint}?${queryString}`, {
    headers: {
      'Authorization': `Bearer ${user.token}`,
      'User-Agent': 'K6-LoadTest/1.0',
      'Accept': 'application/json',
      'Cache-Control': 'no-cache'
    },
    tags: { 
      endpoint: 'feed_load',
      feed_type: feedType.type,
      page: page.toString(),
      limit: limit.toString()
    }
  });
  
  const duration = Date.now() - startTime;
  feedLoadTime.add(duration);
  
  const success = check(response, {
    [`${feedType.type} feed load status is 200`]: (r) => r.status === 200,
    [`${feedType.type} feed load response time < 200ms`]: (r) => r.timings.duration < 200,
    [`${feedType.type} feed load returns posts array`]: (r) => {
      try {
        const data = JSON.parse(r.body);
        return Array.isArray(data.posts) && data.metadata;
      } catch (e) {
        return false;
      }
    },
    [`${feedType.type} feed load has valid pagination`]: (r) => {
      try {
        const data = JSON.parse(r.body);
        return data.metadata && 
               typeof data.metadata.total === 'number' &&
               typeof data.metadata.page === 'number' &&
               typeof data.metadata.limit === 'number';
      } catch (e) {
        return false;
      }
    }
  });
  
  feedLoadRate.add(success);
  
  if (success) {
    // Track content size
    const contentSize = response.body.length;
    feedContentSize.add(contentSize);
    
    // Check for cache headers
    const cacheHeader = response.headers['X-Cache-Status'];
    if (cacheHeader === 'HIT') {
      feedCacheHitRate.add(1);
    } else {
      feedCacheHitRate.add(0);
    }
  } else {
    errorCounter.add(1);
    console.error(`Feed load failed for ${feedType.type}: ${response.status} - ${response.body}`);
  }
  
  return success ? JSON.parse(response.body) : null;
}

// Test feed pagination
function testFeedPagination(feedType, user) {
  const startTime = Date.now();
  
  // Load first page
  const firstPage = loadFeed(feedType, 1, 20, user);
  if (!firstPage) return false;
  
  // Load second page
  const secondPage = loadFeed(feedType, 2, 20, user);
  if (!secondPage) return false;
  
  // Load last page (if available)
  const totalPages = Math.ceil(firstPage.metadata.total / 20);
  if (totalPages > 2) {
    const lastPage = loadFeed(feedType, totalPages, 20, user);
    if (!lastPage) return false;
  }
  
  const duration = Date.now() - startTime;
  feedPaginationTime.add(duration);
  
  const success = check(null, {
    'pagination test completed': () => true,
    'pagination response time < 150ms': () => duration < 150
  });
  
  return success;
}

// Test different page sizes
function testPageSizes(feedType, user) {
  const pageSize = pageSizes[Math.floor(Math.random() * pageSizes.length)];
  
  const response = loadFeed(feedType, 1, pageSize, user);
  
  const success = check(response, {
    [`page size ${pageSize} returns correct number of posts`]: (r) => {
      if (!r) return false;
      return r.posts.length <= pageSize;
    },
    [`page size ${pageSize} response time acceptable`]: (r) => {
      if (!r) return false;
      // Larger page sizes should have slightly higher response times
      const maxTime = pageSize <= 20 ? 200 : pageSize <= 50 ? 300 : 500;
      return true; // We'll track this in the trend metric
    }
  });
  
  return success;
}

// Test feed filtering and sorting
function testFeedFiltering(feedType, user) {
  const filters = [
    { hashtag: 'technology' },
    { hashtag: 'science' },
    { hashtag: 'engineering' },
    { university: 'stanford.edu' },
    { university: 'mit.edu' }
  ];
  
  const filter = filters[Math.floor(Math.random() * filters.length)];
  
  const params = {
    page: 1,
    limit: 20,
    ...filter
  };
  
  const queryString = Object.keys(params)
    .map(key => `${key}=${encodeURIComponent(params[key])}`)
    .join('&');
  
  const response = http.get(`${__ENV.BASE_URL}${feedType.endpoint}?${queryString}`, {
    headers: {
      'Authorization': `Bearer ${user.token}`,
      'User-Agent': 'K6-LoadTest/1.0',
      'Accept': 'application/json'
    },
    tags: { 
      endpoint: 'feed_filter',
      feed_type: feedType.type,
      filter: Object.keys(filter)[0]
    }
  });
  
  const success = check(response, {
    'filtered feed status is 200': (r) => r.status === 200,
    'filtered feed response time < 250ms': (r) => r.timings.duration < 250,
    'filtered feed returns posts': (r) => {
      try {
        const data = JSON.parse(r.body);
        return Array.isArray(data.posts);
      } catch (e) {
        return false;
      }
    }
  });
  
  if (!success) {
    errorCounter.add(1);
    console.error(`Feed filtering failed: ${response.status} - ${response.body}`);
  }
  
  return success;
}

// Test feed refresh (cache invalidation)
function testFeedRefresh(feedType, user) {
  // First request (might be cached)
  const firstResponse = loadFeed(feedType, 1, 20, user);
  if (!firstResponse) return false;
  
  sleep(0.1); // Brief pause
  
  // Second request with cache-busting
  const startTime = Date.now();
  
  const params = {
    page: 1,
    limit: 20,
    _t: Date.now() // Cache buster
  };
  
  const queryString = Object.keys(params)
    .map(key => `${key}=${encodeURIComponent(params[key])}`)
    .join('&');
  
  const response = http.get(`${__ENV.BASE_URL}${feedType.endpoint}?${queryString}`, {
    headers: {
      'Authorization': `Bearer ${user.token}`,
      'User-Agent': 'K6-LoadTest/1.0',
      'Accept': 'application/json',
      'Cache-Control': 'no-cache, no-store, must-revalidate'
    },
    tags: { 
      endpoint: 'feed_refresh',
      feed_type: feedType.type
    }
  });
  
  const duration = Date.now() - startTime;
  
  const success = check(response, {
    'feed refresh status is 200': (r) => r.status === 200,
    'feed refresh response time < 300ms': (r) => r.timings.duration < 300,
    'feed refresh returns fresh data': (r) => {
      try {
        const data = JSON.parse(r.body);
        return Array.isArray(data.posts);
      } catch (e) {
        return false;
      }
    }
  });
  
  if (!success) {
    errorCounter.add(1);
    console.error(`Feed refresh failed: ${response.status} - ${response.body}`);
  }
  
  return success;
}

// Test concurrent feed loads (stress test)
function testConcurrentFeedLoads(feedType, user) {
  const promises = [];
  
  // Simulate multiple concurrent requests
  for (let i = 0; i < 3; i++) {
    const page = Math.floor(Math.random() * 5) + 1;
    const limit = pageSizes[Math.floor(Math.random() * pageSizes.length)];
    
    // Note: k6 doesn't support true concurrency, but we can simulate rapid requests
    const response = loadFeed(feedType, page, limit, user);
    if (!response) return false;
    
    sleep(0.05); // Very brief pause between requests
  }
  
  return true;
}

// Main test function
export default function () {
  const user = getRandomUser();
  const feedType = feedTypes[Math.floor(Math.random() * feedTypes.length)];
  
  // Test 1: Basic feed loading
  const basicLoad = loadFeed(feedType, 1, 20, user);
  if (!basicLoad) {
    return; // Skip remaining tests if basic load fails
  }
  
  sleep(0.5); // Brief pause between test scenarios
  
  // Test 2: Feed pagination
  testFeedPagination(feedType, user);
  
  sleep(0.5);
  
  // Test 3: Different page sizes
  testPageSizes(feedType, user);
  
  sleep(0.5);
  
  // Test 4: Feed filtering
  testFeedFiltering(feedType, user);
  
  sleep(0.5);
  
  // Test 5: Feed refresh
  testFeedRefresh(feedType, user);
  
  sleep(0.5);
  
  // Test 6: Concurrent loads (stress test)
  testConcurrentFeedLoads(feedType, user);
  
  // Brief pause before next iteration
  sleep(1);
}

// Setup function
export function setup() {
  console.log('Starting Feed Loading Performance Load Test');
  console.log(`Base URL: ${__ENV.BASE_URL}`);
  console.log(`Test Duration: ${__ENV.TEST_DURATION || '31 minutes'}`);
  console.log(`Max Users: ${__ENV.MAX_USERS || '500'}`);
  
  // Verify base URL and feed endpoints
  const healthCheck = http.get(`${__ENV.BASE_URL}/health`);
  if (healthCheck.status !== 200) {
    throw new Error(`Health check failed: ${healthCheck.status}`);
  }
  
  // Test feed endpoint accessibility
  const feedCheck = http.get(`${__ENV.BASE_URL}/api/feed/explore?page=1&limit=1`);
  if (feedCheck.status !== 200) {
    throw new Error(`Feed endpoint check failed: ${feedCheck.status}`);
  }
  
  console.log('Health and feed checks passed, starting load test...');
}

// Teardown function
export function teardown(data) {
  console.log('Feed Loading Performance Load Test completed');
  console.log(`Total errors: ${errorCounter.count}`);
  console.log(`Feed load success rate: ${feedLoadRate.rate * 100}%`);
  console.log(`Average feed load time: ${feedLoadTime.avg}ms`);
  console.log(`Average pagination time: ${feedPaginationTime.avg}ms`);
  console.log(`Average content size: ${feedContentSize.avg} bytes`);
  console.log(`Cache hit rate: ${feedCacheHitRate.rate * 100}%`);
}
