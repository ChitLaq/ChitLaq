/**
 * ChitLaq M1 MVP - Real-time Messaging Load Test
 * Generated by PROMPT 1.6 - Performance Optimization & Load Testing Framework
 * Senior Performance Engineer - 15+ years application optimization and load testing experience
 * 
 * Load test for real-time messaging with 1000 WebSocket connections
 * Tests: WebSocket connections, message throughput, latency, connection stability
 */

import ws from 'k6/ws';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter, Gauge } from 'k6/metrics';
import { SharedArray } from 'k6/data';

// Custom metrics
const connectionRate = new Rate('websocket_connection_success_rate');
const messageLatency = new Trend('message_latency');
const messageThroughput = new Counter('messages_sent');
const connectionStability = new Rate('connection_stability_rate');
const errorCounter = new Counter('websocket_errors');
const activeConnections = new Gauge('active_websocket_connections');

// Test configuration
export const options = {
  stages: [
    { duration: '2m', target: 100 },   // Ramp up to 100 connections
    { duration: '3m', target: 500 },   // Ramp up to 500 connections
    { duration: '5m', target: 1000 },  // Ramp up to 1000 connections
    { duration: '20m', target: 1000 }, // Stay at 1000 connections
    { duration: '3m', target: 0 },     // Ramp down to 0 connections
  ],
  thresholds: {
    'websocket_connection_success_rate': ['rate>0.99'], // 99% connection success
    'message_latency': ['p(95)<100'], // 95% under 100ms
    'connection_stability_rate': ['rate>0.95'], // 95% stable connections
    'websocket_errors': ['count<50'], // Less than 50 errors total
  },
};

// Test data
const messageTypes = new SharedArray('messageTypes', function () {
  return [
    'text',
    'emoji',
    'mention',
    'hashtag',
    'link',
    'image_url',
    'file_share'
  ];
});

const messageTemplates = new SharedArray('messageTemplates', function () {
  return [
    'Hello! How are you doing?',
    'Great to see you here! 👋',
    'Check out this cool link: https://example.com',
    'Working on some interesting #technology today',
    'Hey @username, what do you think about this?',
    'Just finished reading an amazing article 📚',
    'The weather is beautiful today! ☀️',
    'Working on a new project, excited to share it soon!',
    'Anyone interested in collaborating on something?',
    'Just discovered this amazing tool, highly recommend!'
  ];
});

const userPairs = new SharedArray('userPairs', function () {
  // Pre-defined user pairs for testing conversations
  return [
    { sender: 'user_1', recipient: 'user_2' },
    { sender: 'user_3', recipient: 'user_4' },
    { sender: 'user_5', recipient: 'user_6' },
    { sender: 'user_7', recipient: 'user_8' },
    { sender: 'user_9', recipient: 'user_10' }
  ];
});

// Generate test message
function generateTestMessage() {
  const template = messageTemplates[Math.floor(Math.random() * messageTemplates.length)];
  const type = messageTypes[Math.floor(Math.random() * messageTypes.length)];
  const timestamp = Date.now();
  
  return {
    type: type,
    content: template,
    timestamp: timestamp,
    messageId: `test_${timestamp}_${Math.floor(Math.random() * 10000)}`
  };
}

// WebSocket connection test
function testWebSocketConnection(userId) {
  const url = `${__ENV.WS_BASE_URL}/ws?token=${userId}`;
  let connectionEstablished = false;
  let messagesReceived = 0;
  let messagesSent = 0;
  let connectionStartTime = 0;
  let lastPingTime = 0;
  
  return new Promise((resolve) => {
    const socket = ws.connect(url, {}, function (socket) {
      connectionStartTime = Date.now();
      connectionEstablished = true;
      activeConnections.add(1);
      
      // Send initial handshake
      socket.send(JSON.stringify({
        type: 'handshake',
        userId: userId,
        timestamp: Date.now()
      }));
      
      // Set up message handlers
      socket.on('message', function (data) {
        try {
          const message = JSON.parse(data);
          messagesReceived++;
          
          // Track message latency
          if (message.timestamp) {
            const latency = Date.now() - message.timestamp;
            messageLatency.add(latency);
          }
          
          // Handle different message types
          switch (message.type) {
            case 'handshake_ack':
              // Connection established successfully
              break;
            case 'message':
              // Regular message received
              break;
            case 'ping':
              // Respond to ping
              socket.send(JSON.stringify({
                type: 'pong',
                timestamp: Date.now()
              }));
              break;
            case 'error':
              errorCounter.add(1);
              console.error(`WebSocket error: ${message.error}`);
              break;
          }
        } catch (e) {
          errorCounter.add(1);
          console.error(`Failed to parse message: ${data}`);
        }
      });
      
      socket.on('close', function () {
        activeConnections.add(-1);
        connectionEstablished = false;
      });
      
      socket.on('error', function (e) {
        errorCounter.add(1);
        console.error(`WebSocket error: ${e}`);
      });
      
      // Send test messages periodically
      const messageInterval = setInterval(() => {
        if (connectionEstablished) {
          const testMessage = generateTestMessage();
          testMessage.recipientId = userPairs[Math.floor(Math.random() * userPairs.length)].recipient;
          
          socket.send(JSON.stringify({
            type: 'message',
            ...testMessage
          }));
          
          messagesSent++;
          messageThroughput.add(1);
        }
      }, 2000 + Math.random() * 3000); // Send message every 2-5 seconds
      
      // Send ping every 30 seconds
      const pingInterval = setInterval(() => {
        if (connectionEstablished) {
          lastPingTime = Date.now();
          socket.send(JSON.stringify({
            type: 'ping',
            timestamp: lastPingTime
          }));
        }
      }, 30000);
      
      // Test for 2-5 minutes
      const testDuration = 120000 + Math.random() * 180000; // 2-5 minutes
      
      setTimeout(() => {
        clearInterval(messageInterval);
        clearInterval(pingInterval);
        
        if (connectionEstablished) {
          socket.close();
        }
        
        // Record test results
        const connectionDuration = Date.now() - connectionStartTime;
        const stability = connectionEstablished && connectionDuration > 60000; // Stable if connected for >1min
        
        resolve({
          connectionEstablished,
          messagesSent,
          messagesReceived,
          connectionDuration,
          stability
        });
      }, testDuration);
    });
    
    // Connection timeout
    setTimeout(() => {
      if (!connectionEstablished) {
        resolve({
          connectionEstablished: false,
          messagesSent: 0,
          messagesReceived: 0,
          connectionDuration: 0,
          stability: false
        });
      }
    }, 10000); // 10 second connection timeout
  });
}

// Test message throughput
function testMessageThroughput(userId) {
  const url = `${__ENV.WS_BASE_URL}/ws?token=${userId}`;
  let messagesSent = 0;
  let messagesReceived = 0;
  let startTime = 0;
  
  return new Promise((resolve) => {
    const socket = ws.connect(url, {}, function (socket) {
      startTime = Date.now();
      
      socket.on('message', function (data) {
        try {
          const message = JSON.parse(data);
          messagesReceived++;
          
          if (message.type === 'message_ack') {
            const latency = Date.now() - message.originalTimestamp;
            messageLatency.add(latency);
          }
        } catch (e) {
          errorCounter.add(1);
        }
      });
      
      // Send messages as fast as possible for 30 seconds
      const sendInterval = setInterval(() => {
        const testMessage = generateTestMessage();
        testMessage.recipientId = userPairs[Math.floor(Math.random() * userPairs.length)].recipient;
        testMessage.originalTimestamp = Date.now();
        
        socket.send(JSON.stringify({
          type: 'message',
          ...testMessage
        }));
        
        messagesSent++;
        messageThroughput.add(1);
      }, 100); // Send message every 100ms
      
      setTimeout(() => {
        clearInterval(sendInterval);
        socket.close();
        
        const duration = Date.now() - startTime;
        const throughput = (messagesSent / duration) * 1000; // messages per second
        
        resolve({
          messagesSent,
          messagesReceived,
          duration,
          throughput
        });
      }, 30000); // 30 second throughput test
    });
  });
}

// Test connection stability under load
function testConnectionStability(userId) {
  const url = `${__ENV.WS_BASE_URL}/ws?token=${userId}`;
  let connectionDrops = 0;
  let reconnections = 0;
  let startTime = 0;
  
  return new Promise((resolve) => {
    const socket = ws.connect(url, {}, function (socket) {
      startTime = Date.now();
      
      socket.on('close', function () {
        connectionDrops++;
        
        // Attempt reconnection
        setTimeout(() => {
          reconnections++;
          // Note: k6 doesn't support reconnection, so we simulate it
        }, 1000);
      });
      
      socket.on('error', function (e) {
        errorCounter.add(1);
        console.error(`Connection error: ${e}`);
      });
      
      // Send periodic messages to keep connection alive
      const keepAliveInterval = setInterval(() => {
        socket.send(JSON.stringify({
          type: 'ping',
          timestamp: Date.now()
        }));
      }, 10000); // Ping every 10 seconds
      
      setTimeout(() => {
        clearInterval(keepAliveInterval);
        socket.close();
        
        const duration = Date.now() - startTime;
        const stability = connectionDrops === 0; // Stable if no drops
        
        resolve({
          connectionDrops,
          reconnections,
          duration,
          stability
        });
      }, 300000); // 5 minute stability test
    });
  });
}

// Test concurrent message handling
function testConcurrentMessages(userId) {
  const url = `${__ENV.WS_BASE_URL}/ws?token=${userId}`;
  let concurrentMessages = 0;
  let maxConcurrent = 0;
  let messagesProcessed = 0;
  
  return new Promise((resolve) => {
    const socket = ws.connect(url, {}, function (socket) {
      socket.on('message', function (data) {
        try {
          const message = JSON.parse(data);
          concurrentMessages++;
          maxConcurrent = Math.max(maxConcurrent, concurrentMessages);
          
          // Simulate message processing time
          setTimeout(() => {
            concurrentMessages--;
            messagesProcessed++;
          }, 50 + Math.random() * 100); // 50-150ms processing time
          
        } catch (e) {
          errorCounter.add(1);
        }
      });
      
      // Send burst of messages
      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          const testMessage = generateTestMessage();
          testMessage.recipientId = userPairs[Math.floor(Math.random() * userPairs.length)].recipient;
          
          socket.send(JSON.stringify({
            type: 'message',
            ...testMessage
          }));
        }, i * 10); // Send message every 10ms
      }
      
      setTimeout(() => {
        socket.close();
        resolve({
          maxConcurrent,
          messagesProcessed
        });
      }, 10000); // 10 second test
    });
  });
}

// Main test function
export default function () {
  const userId = `loadtest_user_${Math.floor(Math.random() * 1000)}`;
  
  // Test 1: Basic WebSocket connection
  const connectionTest = testWebSocketConnection(userId);
  
  // Test 2: Message throughput (run in parallel)
  const throughputTest = testMessageThroughput(userId);
  
  // Test 3: Connection stability
  const stabilityTest = testConnectionStability(userId);
  
  // Test 4: Concurrent message handling
  const concurrentTest = testConcurrentMessages(userId);
  
  // Wait for all tests to complete
  Promise.all([connectionTest, throughputTest, stabilityTest, concurrentTest])
    .then(([connection, throughput, stability, concurrent]) => {
      // Record results
      connectionRate.add(connection.connectionEstablished);
      connectionStability.add(stability.stability);
      
      // Log results
      console.log(`User ${userId} - Connection: ${connection.connectionEstablished}, Messages: ${connection.messagesSent}, Stability: ${stability.stability}`);
    })
    .catch((error) => {
      errorCounter.add(1);
      console.error(`Test failed for user ${userId}: ${error}`);
    });
  
  // Brief pause before next iteration
  sleep(1);
}

// Setup function
export function setup() {
  console.log('Starting Real-time Messaging Load Test');
  console.log(`WebSocket URL: ${__ENV.WS_BASE_URL}`);
  console.log(`Test Duration: ${__ENV.TEST_DURATION || '33 minutes'}`);
  console.log(`Max Connections: ${__ENV.MAX_CONNECTIONS || '1000'}`);
  
  // Verify WebSocket endpoint
  const healthCheck = ws.connect(`${__ENV.WS_BASE_URL}/health`, {}, function (socket) {
    socket.on('open', function () {
      console.log('WebSocket health check passed');
      socket.close();
    });
    
    socket.on('error', function (e) {
      throw new Error(`WebSocket health check failed: ${e}`);
    });
  });
  
  console.log('WebSocket health check completed, starting load test...');
}

// Teardown function
export function teardown(data) {
  console.log('Real-time Messaging Load Test completed');
  console.log(`Total errors: ${errorCounter.count}`);
  console.log(`Connection success rate: ${connectionRate.rate * 100}%`);
  console.log(`Average message latency: ${messageLatency.avg}ms`);
  console.log(`Total messages sent: ${messageThroughput.count}`);
  console.log(`Connection stability rate: ${connectionStability.rate * 100}%`);
  console.log(`Active connections: ${activeConnections.value}`);
}
