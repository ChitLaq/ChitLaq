#!/usr/bin/env node

/**
 * ChitLaq M1 MVP - Performance Benchmarking Suite
 * Generated by PROMPT 1.4 - Monitoring & Observability Stack
 * Senior SRE - 15+ years monitoring and incident response experience
 * 
 * Comprehensive performance testing suite for all ChitLaq services
 * Includes load testing, stress testing, and performance baselines
 */

const { performance } = require('perf_hooks');
const fs = require('fs').promises;
const path = require('path');

// Test configuration
const CONFIG = {
  // Base URLs for different environments
  BASE_URLS: {
    local: 'http://localhost:3001',
    staging: 'https://staging.chitlaq.com',
    production: 'https://chitlaq.com'
  },
  
  // Test scenarios
  SCENARIOS: {
    // Load testing scenarios
    load: {
      users: 100,
      duration: '5m',
      rampUp: '1m'
    },
    // Stress testing scenarios
    stress: {
      users: 500,
      duration: '10m',
      rampUp: '2m'
    },
    // Spike testing scenarios
    spike: {
      users: 1000,
      duration: '2m',
      rampUp: '30s'
    }
  },
  
  // Performance thresholds
  THRESHOLDS: {
    // Response time thresholds (ms)
    responseTime: {
      p50: 200,
      p95: 500,
      p99: 1000
    },
    // Error rate thresholds (%)
    errorRate: {
      max: 1
    },
    // Throughput thresholds (req/s)
    throughput: {
      min: 100
    }
  },
  
  // Test data
  TEST_DATA: {
    universities: [
      'stanford.edu',
      'mit.edu',
      'harvard.edu',
      'berkeley.edu',
      'cmu.edu'
    ],
    sampleUsers: [
      {
        email: 'test1@stanford.edu',
        username: 'testuser1',
        password: 'TestPassword123!'
      },
      {
        email: 'test2@mit.edu',
        username: 'testuser2',
        password: 'TestPassword123!'
      }
    ]
  }
};

// Performance metrics collector
class PerformanceMetrics {
  constructor() {
    this.metrics = {
      responseTimes: [],
      errorRates: [],
      throughput: [],
      memoryUsage: [],
      cpuUsage: [],
      databaseConnections: [],
      websocketConnections: []
    };
    this.startTime = performance.now();
  }

  recordResponseTime(time) {
    this.metrics.responseTimes.push(time);
  }

  recordError(error) {
    this.metrics.errorRates.push(error);
  }

  recordThroughput(requests, duration) {
    this.metrics.throughput.push(requests / duration);
  }

  recordSystemMetrics(metrics) {
    this.metrics.memoryUsage.push(metrics.memory);
    this.metrics.cpuUsage.push(metrics.cpu);
    this.metrics.databaseConnections.push(metrics.dbConnections);
    this.metrics.websocketConnections.push(metrics.wsConnections);
  }

  getStats() {
    const responseTimes = this.metrics.responseTimes;
    const sorted = responseTimes.sort((a, b) => a - b);
    
    return {
      responseTime: {
        min: Math.min(...responseTimes),
        max: Math.max(...responseTimes),
        mean: responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length,
        p50: sorted[Math.floor(sorted.length * 0.5)],
        p95: sorted[Math.floor(sorted.length * 0.95)],
        p99: sorted[Math.floor(sorted.length * 0.99)]
      },
      errorRate: (this.metrics.errorRates.length / this.metrics.responseTimes.length) * 100,
      throughput: this.metrics.throughput.reduce((a, b) => a + b, 0) / this.metrics.throughput.length,
      duration: performance.now() - this.startTime
    };
  }

  async saveResults(filename) {
    const results = {
      timestamp: new Date().toISOString(),
      stats: this.getStats(),
      rawMetrics: this.metrics
    };
    
    await fs.writeFile(filename, JSON.stringify(results, null, 2));
    return results;
  }
}

// HTTP client for API testing
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.session = null;
  }

  async request(method, endpoint, data = null, headers = {}) {
    const startTime = performance.now();
    
    try {
      const url = `${this.baseURL}${endpoint}`;
      const options = {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        }
      };

      if (this.session) {
        options.headers.Authorization = `Bearer ${this.session.token}`;
      }

      if (data) {
        options.body = JSON.stringify(data);
      }

      const response = await fetch(url, options);
      const responseTime = performance.now() - startTime;
      
      return {
        status: response.status,
        data: await response.json(),
        responseTime,
        success: response.ok
      };
    } catch (error) {
      const responseTime = performance.now() - startTime;
      return {
        status: 0,
        data: null,
        responseTime,
        success: false,
        error: error.message
      };
    }
  }

  async login(email, password) {
    const response = await this.request('POST', '/api/auth/login', {
      email,
      password
    });
    
    if (response.success) {
      this.session = response.data;
    }
    
    return response;
  }

  async register(userData) {
    return await this.request('POST', '/api/auth/register', userData);
  }

  async createPost(content) {
    return await this.request('POST', '/api/posts', { content });
  }

  async getFeed(page = 1) {
    return await this.request('GET', `/api/feed?page=${page}`);
  }

  async search(query) {
    return await this.request('GET', `/api/search?q=${encodeURIComponent(query)}`);
  }

  async getProfile(userId) {
    return await this.request('GET', `/api/users/${userId}`);
  }

  async sendMessage(recipientId, content) {
    return await this.request('POST', '/api/messages', {
      recipientId,
      content
    });
  }
}

// WebSocket client for real-time testing
class WebSocketClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.ws = null;
    this.messages = [];
    this.connected = false;
  }

  async connect(token) {
    return new Promise((resolve, reject) => {
      const wsUrl = this.baseURL.replace('http', 'ws') + `/ws?token=${token}`;
      this.ws = new WebSocket(wsUrl);
      
      this.ws.onopen = () => {
        this.connected = true;
        resolve();
      };
      
      this.ws.onmessage = (event) => {
        this.messages.push({
          timestamp: performance.now(),
          data: JSON.parse(event.data)
        });
      };
      
      this.ws.onerror = (error) => {
        reject(error);
      };
      
      this.ws.onclose = () => {
        this.connected = false;
      };
    });
  }

  sendMessage(type, data) {
    if (this.connected) {
      this.ws.send(JSON.stringify({ type, data }));
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}

// Test scenarios
class TestScenarios {
  constructor(apiClient, wsClient, metrics) {
    this.api = apiClient;
    this.ws = wsClient;
    this.metrics = metrics;
  }

  async testUserRegistration() {
    console.log('Testing user registration...');
    
    const user = CONFIG.TEST_DATA.sampleUsers[0];
    const response = await this.api.register(user);
    
    this.metrics.recordResponseTime(response.responseTime);
    if (!response.success) {
      this.metrics.recordError(response);
    }
    
    return response;
  }

  async testUserLogin() {
    console.log('Testing user login...');
    
    const user = CONFIG.TEST_DATA.sampleUsers[0];
    const response = await this.api.login(user.email, user.password);
    
    this.metrics.recordResponseTime(response.responseTime);
    if (!response.success) {
      this.metrics.recordError(response);
    }
    
    return response;
  }

  async testPostCreation() {
    console.log('Testing post creation...');
    
    const content = `Test post created at ${new Date().toISOString()}`;
    const response = await this.api.createPost(content);
    
    this.metrics.recordResponseTime(response.responseTime);
    if (!response.success) {
      this.metrics.recordError(response);
    }
    
    return response;
  }

  async testFeedGeneration() {
    console.log('Testing feed generation...');
    
    const response = await this.api.getFeed(1);
    
    this.metrics.recordResponseTime(response.responseTime);
    if (!response.success) {
      this.metrics.recordError(response);
    }
    
    return response;
  }

  async testSearchFunctionality() {
    console.log('Testing search functionality...');
    
    const queries = ['test', 'university', 'post', 'user'];
    const results = [];
    
    for (const query of queries) {
      const response = await this.api.search(query);
      this.metrics.recordResponseTime(response.responseTime);
      if (!response.success) {
        this.metrics.recordError(response);
      }
      results.push(response);
    }
    
    return results;
  }

  async testWebSocketConnection() {
    console.log('Testing WebSocket connection...');
    
    try {
      await this.ws.connect(this.api.session?.token);
      this.metrics.recordResponseTime(performance.now());
      return { success: true };
    } catch (error) {
      this.metrics.recordError(error);
      return { success: false, error: error.message };
    }
  }

  async testMessageSending() {
    console.log('Testing message sending...');
    
    const response = await this.api.sendMessage('test-user-id', 'Test message');
    
    this.metrics.recordResponseTime(response.responseTime);
    if (!response.success) {
      this.metrics.recordError(response);
    }
    
    return response;
  }

  async testConcurrentUsers(userCount) {
    console.log(`Testing ${userCount} concurrent users...`);
    
    const promises = [];
    for (let i = 0; i < userCount; i++) {
      promises.push(this.testUserLogin());
    }
    
    const results = await Promise.all(promises);
    return results;
  }

  async testDatabasePerformance() {
    console.log('Testing database performance...');
    
    const queries = [
      () => this.api.getFeed(1),
      () => this.api.search('test'),
      () => this.api.getProfile('test-user-id')
    ];
    
    const results = [];
    for (const query of queries) {
      const startTime = performance.now();
      const response = await query();
      const endTime = performance.now();
      
      results.push({
        query: query.name,
        responseTime: endTime - startTime,
        success: response.success
      });
    }
    
    return results;
  }
}

// Load testing orchestrator
class LoadTester {
  constructor(baseURL, scenario) {
    this.baseURL = baseURL;
    this.scenario = scenario;
    this.metrics = new PerformanceMetrics();
    this.results = [];
  }

  async runLoadTest() {
    console.log(`Starting load test: ${this.scenario.name}`);
    console.log(`Users: ${this.scenario.users}, Duration: ${this.scenario.duration}`);
    
    const startTime = performance.now();
    const endTime = startTime + this.parseDuration(this.scenario.duration);
    
    // Create user sessions
    const users = [];
    for (let i = 0; i < this.scenario.users; i++) {
      const apiClient = new APIClient(this.baseURL);
      const wsClient = new WebSocketClient(this.baseURL);
      users.push({ api: apiClient, ws: wsClient });
    }
    
    // Ramp up users
    await this.rampUpUsers(users);
    
    // Run test for specified duration
    while (performance.now() < endTime) {
      await this.runTestCycle(users);
      await this.sleep(1000); // 1 second between cycles
    }
    
    // Cleanup
    users.forEach(user => {
      user.ws.disconnect();
    });
    
    const results = await this.metrics.saveResults(`load-test-${this.scenario.name}-${Date.now()}.json`);
    return results;
  }

  async rampUpUsers(users) {
    const rampUpTime = this.parseDuration(this.scenario.rampUp);
    const userDelay = rampUpTime / users.length;
    
    for (let i = 0; i < users.length; i++) {
      const user = users[i];
      
      // Login user
      const loginResponse = await user.api.login(
        CONFIG.TEST_DATA.sampleUsers[0].email,
        CONFIG.TEST_DATA.sampleUsers[0].password
      );
      
      if (loginResponse.success) {
        // Connect WebSocket
        try {
          await user.ws.connect(user.api.session.token);
        } catch (error) {
          console.warn(`WebSocket connection failed for user ${i}:`, error.message);
        }
      }
      
      await this.sleep(userDelay);
    }
  }

  async runTestCycle(users) {
    const promises = users.map(async (user) => {
      const scenarios = new TestScenarios(user.api, user.ws, this.metrics);
      
      // Randomly select test scenario
      const testMethods = [
        'testPostCreation',
        'testFeedGeneration',
        'testSearchFunctionality',
        'testMessageSending'
      ];
      
      const randomMethod = testMethods[Math.floor(Math.random() * testMethods.length)];
      await scenarios[randomMethod]();
    });
    
    await Promise.all(promises);
  }

  parseDuration(duration) {
    const match = duration.match(/(\d+)([smh])/);
    if (!match) return 0;
    
    const value = parseInt(match[1]);
    const unit = match[2];
    
    switch (unit) {
      case 's': return value * 1000;
      case 'm': return value * 60 * 1000;
      case 'h': return value * 60 * 60 * 1000;
      default: return 0;
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Performance baseline tests
class BaselineTests {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async runBaselineTests() {
    console.log('Running baseline performance tests...');
    
    const apiClient = new APIClient(this.baseURL);
    const wsClient = new WebSocketClient(this.baseURL);
    const metrics = new PerformanceMetrics();
    const scenarios = new TestScenarios(apiClient, wsClient, metrics);
    
    // Run individual tests
    await scenarios.testUserRegistration();
    await scenarios.testUserLogin();
    await scenarios.testPostCreation();
    await scenarios.testFeedGeneration();
    await scenarios.testSearchFunctionality();
    await scenarios.testWebSocketConnection();
    await scenarios.testMessageSending();
    
    // Run database performance tests
    await scenarios.testDatabasePerformance();
    
    const results = await metrics.saveResults(`baseline-test-${Date.now()}.json`);
    return results;
  }
}

// Main test runner
class PerformanceTestRunner {
  constructor(environment = 'local') {
    this.baseURL = CONFIG.BASE_URLS[environment];
    this.results = [];
  }

  async runAllTests() {
    console.log(`Running performance tests against: ${this.baseURL}`);
    
    // Run baseline tests
    console.log('\n=== BASELINE TESTS ===');
    const baselineResults = await new BaselineTests(this.baseURL).runBaselineTests();
    this.results.push({ type: 'baseline', results: baselineResults });
    
    // Run load tests
    console.log('\n=== LOAD TESTS ===');
    for (const [name, scenario] of Object.entries(CONFIG.SCENARIOS)) {
      const loadTester = new LoadTester(this.baseURL, { name, ...scenario });
      const loadResults = await loadTester.runLoadTest();
      this.results.push({ type: 'load', scenario: name, results: loadResults });
    }
    
    // Generate report
    await this.generateReport();
    
    return this.results;
  }

  async generateReport() {
    console.log('\n=== PERFORMANCE TEST REPORT ===');
    
    const report = {
      timestamp: new Date().toISOString(),
      environment: this.baseURL,
      summary: this.generateSummary(),
      detailedResults: this.results
    };
    
    const filename = `performance-report-${Date.now()}.json`;
    await fs.writeFile(filename, JSON.stringify(report, null, 2));
    
    console.log(`Report saved to: ${filename}`);
    this.printSummary(report.summary);
  }

  generateSummary() {
    const summary = {
      totalTests: this.results.length,
      passed: 0,
      failed: 0,
      averageResponseTime: 0,
      maxResponseTime: 0,
      errorRate: 0
    };
    
    let totalResponseTime = 0;
    let totalRequests = 0;
    let totalErrors = 0;
    
    this.results.forEach(result => {
      const stats = result.results.stats;
      totalResponseTime += stats.responseTime.mean;
      totalRequests += result.results.rawMetrics.responseTimes.length;
      totalErrors += result.results.rawMetrics.errorRates.length;
      
      if (stats.responseTime.mean < CONFIG.THRESHOLDS.responseTime.p95) {
        summary.passed++;
      } else {
        summary.failed++;
      }
    });
    
    summary.averageResponseTime = totalResponseTime / this.results.length;
    summary.errorRate = (totalErrors / totalRequests) * 100;
    
    return summary;
  }

  printSummary(summary) {
    console.log('\n=== SUMMARY ===');
    console.log(`Total Tests: ${summary.totalTests}`);
    console.log(`Passed: ${summary.passed}`);
    console.log(`Failed: ${summary.failed}`);
    console.log(`Average Response Time: ${summary.averageResponseTime.toFixed(2)}ms`);
    console.log(`Error Rate: ${summary.errorRate.toFixed(2)}%`);
    
    // Check against thresholds
    console.log('\n=== THRESHOLD CHECKS ===');
    console.log(`Response Time (P95): ${summary.averageResponseTime < CONFIG.THRESHOLDS.responseTime.p95 ? '✅ PASS' : '❌ FAIL'}`);
    console.log(`Error Rate: ${summary.errorRate < CONFIG.THRESHOLDS.errorRate.max ? '✅ PASS' : '❌ FAIL'}`);
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  const environment = args[0] || 'local';
  const testType = args[1] || 'all';
  
  console.log('ChitLaq M1 MVP Performance Testing Suite');
  console.log('==========================================');
  
  const runner = new PerformanceTestRunner(environment);
  
  try {
    switch (testType) {
      case 'baseline':
        const baselineResults = await new BaselineTests(runner.baseURL).runBaselineTests();
        console.log('Baseline tests completed');
        break;
        
      case 'load':
        const loadTester = new LoadTester(runner.baseURL, { name: 'load', ...CONFIG.SCENARIOS.load });
        await loadTester.runLoadTest();
        console.log('Load tests completed');
        break;
        
      case 'stress':
        const stressTester = new LoadTester(runner.baseURL, { name: 'stress', ...CONFIG.SCENARIOS.stress });
        await stressTester.runLoadTest();
        console.log('Stress tests completed');
        break;
        
      case 'all':
      default:
        await runner.runAllTests();
        console.log('All tests completed');
        break;
    }
  } catch (error) {
    console.error('Test execution failed:', error);
    process.exit(1);
  }
}

// Export for use in other modules
module.exports = {
  PerformanceTestRunner,
  BaselineTests,
  LoadTester,
  TestScenarios,
  APIClient,
  WebSocketClient,
  PerformanceMetrics,
  CONFIG
};

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}
