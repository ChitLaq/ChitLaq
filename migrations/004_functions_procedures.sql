-- ChitLaq M1 MVP - Database Functions and Procedures
-- High-performance stored procedures for complex social media operations
-- Generated by PROMPT 1.3 - Database Schema & Migrations

-- =====================================================
-- FEED GENERATION FUNCTIONS
-- =====================================================

-- Function to generate personalized feed for a user
CREATE OR REPLACE FUNCTION get_user_feed(
    target_user_id UUID,
    limit_count INTEGER DEFAULT 20,
    offset_count INTEGER DEFAULT 0,
    feed_type TEXT DEFAULT 'timeline' -- 'timeline', 'popular', 'following'
)
RETURNS TABLE(
    post_id UUID,
    author_id UUID,
    author_username VARCHAR(50),
    author_display_name VARCHAR(100),
    author_avatar_url VARCHAR(500),
    author_is_verified BOOLEAN,
    content TEXT,
    post_type post_type,
    privacy_level privacy_level,
    likes_count INTEGER,
    comments_count INTEGER,
    shares_count INTEGER,
    views_count INTEGER,
    media_urls TEXT[],
    location VARCHAR(100),
    tagged_users UUID[],
    created_at TIMESTAMP WITH TIME ZONE,
    is_liked_by_user BOOLEAN,
    is_shared_by_user BOOLEAN
) AS $$
DECLARE
    blocked_users UUID[];
    users_who_blocked_me UUID[];
BEGIN
    -- Get blocked users for filtering
    SELECT auth.get_blocked_users() INTO blocked_users;
    SELECT auth.get_users_who_blocked_me() INTO users_who_blocked_me;
    
    RETURN QUERY
    WITH filtered_posts AS (
        SELECT 
            p.id,
            p.author_id,
            p.content,
            p.post_type,
            p.privacy_level,
            p.likes_count,
            p.comments_count,
            p.shares_count,
            p.views_count,
            p.media_urls,
            p.location,
            p.tagged_users,
            p.created_at,
            -- Engagement score for ranking
            CASE 
                WHEN feed_type = 'popular' THEN
                    (p.likes_count * 1.0 + p.comments_count * 2.0 + p.shares_count * 3.0) / 
                    GREATEST(EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600, 1)
                ELSE 
                    EXTRACT(EPOCH FROM p.created_at)
            END AS engagement_score
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE 
            p.deleted_at IS NULL
            AND NOT p.is_hidden
            AND u.status = 'active'
            -- Privacy filtering
            AND (
                p.privacy_level = 'public' OR
                (p.privacy_level = 'followers' AND (
                    p.author_id = target_user_id OR
                    EXISTS(
                        SELECT 1 FROM user_relationships ur
                        WHERE ur.follower_id = target_user_id
                        AND ur.following_id = p.author_id
                        AND ur.relationship_type = 'follow'
                    )
                )) OR
                p.author_id = target_user_id
            )
            -- Block filtering
            AND (blocked_users IS NULL OR NOT (p.author_id = ANY(blocked_users)))
            AND (users_who_blocked_me IS NULL OR NOT (p.author_id = ANY(users_who_blocked_me)))
            -- Feed type filtering
            AND CASE 
                WHEN feed_type = 'following' THEN
                    p.author_id = target_user_id OR
                    EXISTS(
                        SELECT 1 FROM user_relationships ur
                        WHERE ur.follower_id = target_user_id
                        AND ur.following_id = p.author_id
                        AND ur.relationship_type = 'follow'
                    )
                WHEN feed_type = 'popular' THEN
                    p.created_at > NOW() - INTERVAL '7 days'
                ELSE TRUE
            END
    )
    SELECT 
        fp.id,
        fp.author_id,
        u.username,
        u.display_name,
        u.avatar_url,
        u.is_verified,
        fp.content,
        fp.post_type,
        fp.privacy_level,
        fp.likes_count,
        fp.comments_count,
        fp.shares_count,
        fp.views_count,
        fp.media_urls,
        fp.location,
        fp.tagged_users,
        fp.created_at,
        -- Check if user liked this post
        EXISTS(
            SELECT 1 FROM post_likes pl 
            WHERE pl.post_id = fp.id AND pl.user_id = target_user_id
        ) AS is_liked_by_user,
        -- Check if user shared this post
        EXISTS(
            SELECT 1 FROM post_shares ps 
            WHERE ps.original_post_id = fp.id AND ps.user_id = target_user_id
        ) AS is_shared_by_user
    FROM filtered_posts fp
    JOIN users u ON fp.author_id = u.id
    ORDER BY 
        CASE WHEN feed_type = 'popular' THEN fp.engagement_score ELSE NULL END DESC,
        fp.created_at DESC
    LIMIT limit_count OFFSET offset_count;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to get trending hashtags
CREATE OR REPLACE FUNCTION get_trending_hashtags(
    limit_count INTEGER DEFAULT 10,
    time_period INTERVAL DEFAULT '24 hours'
)
RETURNS TABLE(
    hashtag_id INTEGER,
    hashtag_name VARCHAR(100),
    usage_count INTEGER,
    recent_usage_count BIGINT,
    trending_score REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        h.id,
        h.name,
        h.usage_count,
        COUNT(ph.hashtag_id) AS recent_usage_count,
        -- Calculate trending score based on recent usage vs historical average
        CASE 
            WHEN h.usage_count > 0 THEN
                (COUNT(ph.hashtag_id)::REAL / EXTRACT(EPOCH FROM time_period) * 86400) / 
                (h.usage_count::REAL / GREATEST(EXTRACT(EPOCH FROM NOW() - h.created_at) / 86400, 1))
            ELSE COUNT(ph.hashtag_id)::REAL
        END AS trending_score
    FROM hashtags h
    LEFT JOIN post_hashtags ph ON h.id = ph.hashtag_id
    LEFT JOIN posts p ON ph.post_id = p.id
    WHERE (
        p.created_at IS NULL OR 
        p.created_at > NOW() - time_period
    )
    AND (p.deleted_at IS NULL OR p.deleted_at IS NULL)
    GROUP BY h.id, h.name, h.usage_count, h.created_at
    HAVING COUNT(ph.hashtag_id) > 0
    ORDER BY trending_score DESC, recent_usage_count DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql STABLE;

-- =====================================================
-- SEARCH FUNCTIONS
-- =====================================================

-- Comprehensive search function
CREATE OR REPLACE FUNCTION search_content(
    search_query TEXT,
    search_types TEXT[] DEFAULT ARRAY['users', 'posts', 'hashtags'],
    target_user_id UUID DEFAULT NULL,
    limit_count INTEGER DEFAULT 20
)
RETURNS TABLE(
    result_type TEXT,
    result_id UUID,
    result_data JSONB,
    relevance_score REAL
) AS $$
DECLARE
    normalized_query TEXT;
    blocked_users UUID[];
    users_who_blocked_me UUID[];
BEGIN
    -- Normalize search query
    normalized_query := LOWER(TRIM(search_query));
    
    -- Get blocked users if target_user_id is provided
    IF target_user_id IS NOT NULL THEN
        SELECT auth.get_blocked_users() INTO blocked_users;
        SELECT auth.get_users_who_blocked_me() INTO users_who_blocked_me;
    END IF;
    
    -- Search users
    IF 'users' = ANY(search_types) THEN
        RETURN QUERY
        SELECT 
            'user'::TEXT,
            u.id,
            jsonb_build_object(
                'username', u.username,
                'display_name', u.display_name,
                'avatar_url', u.avatar_url,
                'is_verified', u.is_verified,
                'followers_count', u.followers_count,
                'bio', u.bio
            ),
            -- Calculate relevance score
            CASE 
                WHEN LOWER(u.username) = normalized_query THEN 100.0
                WHEN LOWER(u.username) LIKE normalized_query || '%' THEN 90.0
                WHEN LOWER(u.display_name) = normalized_query THEN 85.0
                WHEN LOWER(u.display_name) LIKE normalized_query || '%' THEN 80.0
                WHEN LOWER(u.username) LIKE '%' || normalized_query || '%' THEN 70.0
                WHEN LOWER(u.display_name) LIKE '%' || normalized_query || '%' THEN 65.0
                ELSE similarity(LOWER(u.username || ' ' || COALESCE(u.display_name, '')), normalized_query) * 50.0
            END AS relevance_score
        FROM users u
        WHERE 
            u.status = 'active'
            AND (
                LOWER(u.username) LIKE '%' || normalized_query || '%' OR
                LOWER(u.display_name) LIKE '%' || normalized_query || '%' OR
                u.username % normalized_query OR
                u.display_name % normalized_query
            )
            -- Privacy and blocking filters
            AND (
                target_user_id IS NULL OR
                u.id = target_user_id OR
                (
                    (NOT u.is_private OR EXISTS(
                        SELECT 1 FROM user_relationships ur
                        WHERE ur.follower_id = target_user_id
                        AND ur.following_id = u.id
                        AND ur.relationship_type = 'follow'
                    )) AND
                    (blocked_users IS NULL OR NOT (u.id = ANY(blocked_users))) AND
                    (users_who_blocked_me IS NULL OR NOT (u.id = ANY(users_who_blocked_me)))
                )
            )
        ORDER BY relevance_score DESC
        LIMIT limit_count;
    END IF;
    
    -- Search posts
    IF 'posts' = ANY(search_types) THEN
        RETURN QUERY
        SELECT 
            'post'::TEXT,
            p.id,
            jsonb_build_object(
                'author_id', p.author_id,
                'author_username', u.username,
                'content', LEFT(p.content, 200),
                'post_type', p.post_type,
                'likes_count', p.likes_count,
                'comments_count', p.comments_count,
                'created_at', p.created_at,
                'media_urls', p.media_urls
            ),
            -- Text search relevance
            CASE 
                WHEN p.search_vector @@ plainto_tsquery('english', search_query) THEN
                    ts_rank(p.search_vector, plainto_tsquery('english', search_query)) * 100.0
                ELSE
                    similarity(LOWER(p.content), normalized_query) * 50.0
            END AS relevance_score
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE 
            p.deleted_at IS NULL
            AND NOT p.is_hidden
            AND u.status = 'active'
            AND (
                p.search_vector @@ plainto_tsquery('english', search_query) OR
                LOWER(p.content) LIKE '%' || normalized_query || '%'
            )
            -- Privacy filtering
            AND (
                target_user_id IS NULL OR
                p.privacy_level = 'public' OR
                p.author_id = target_user_id OR
                (p.privacy_level = 'followers' AND EXISTS(
                    SELECT 1 FROM user_relationships ur
                    WHERE ur.follower_id = target_user_id
                    AND ur.following_id = p.author_id
                    AND ur.relationship_type = 'follow'
                ))
            )
            -- Block filtering
            AND (
                target_user_id IS NULL OR (
                    (blocked_users IS NULL OR NOT (p.author_id = ANY(blocked_users))) AND
                    (users_who_blocked_me IS NULL OR NOT (p.author_id = ANY(users_who_blocked_me)))
                )
            )
        ORDER BY relevance_score DESC
        LIMIT limit_count;
    END IF;
    
    -- Search hashtags
    IF 'hashtags' = ANY(search_types) THEN
        RETURN QUERY
        SELECT 
            'hashtag'::TEXT,
            h.id::UUID,
            jsonb_build_object(
                'name', h.name,
                'usage_count', h.usage_count,
                'last_used_at', h.last_used_at
            ),
            -- Hashtag relevance
            CASE 
                WHEN LOWER(h.name) = normalized_query THEN 100.0
                WHEN LOWER(h.name) LIKE normalized_query || '%' THEN 90.0
                WHEN LOWER(h.name) LIKE '%' || normalized_query || '%' THEN 80.0
                ELSE similarity(LOWER(h.name), normalized_query) * 70.0
            END AS relevance_score
        FROM hashtags h
        WHERE 
            LOWER(h.name) LIKE '%' || normalized_query || '%' OR
            h.name % normalized_query
        ORDER BY relevance_score DESC, usage_count DESC
        LIMIT limit_count;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =====================================================
-- NOTIFICATION FUNCTIONS
-- =====================================================

-- Function to create notifications
CREATE OR REPLACE FUNCTION create_notification(
    target_user_id UUID,
    notification_type notification_type,
    title VARCHAR(200),
    message TEXT DEFAULT NULL,
    actor_id UUID DEFAULT NULL,
    post_id UUID DEFAULT NULL,
    comment_id UUID DEFAULT NULL,
    conversation_id UUID DEFAULT NULL,
    metadata JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    notification_id UUID;
    user_preferences RECORD;
BEGIN
    -- Check if user wants this type of notification
    SELECT * INTO user_preferences
    FROM notification_preferences
    WHERE user_id = target_user_id;
    
    -- If no preferences found, use defaults (all enabled)
    IF user_preferences IS NULL THEN
        INSERT INTO notification_preferences (user_id) VALUES (target_user_id);
        user_preferences := ROW(
            target_user_id, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
            NULL, NULL, NULL, NOW(), NOW()
        );
    END IF;
    
    -- Check if notification type is enabled
    IF (
        (notification_type = 'like' AND NOT user_preferences.likes_enabled) OR
        (notification_type = 'comment' AND NOT user_preferences.comments_enabled) OR
        (notification_type = 'follow' AND NOT user_preferences.follows_enabled) OR
        (notification_type = 'mention' AND NOT user_preferences.mentions_enabled) OR
        (notification_type = 'message' AND NOT user_preferences.messages_enabled) OR
        (notification_type = 'system' AND NOT user_preferences.system_enabled)
    ) THEN
        RETURN NULL;
    END IF;
    
    -- Check for duplicate notifications (prevent spam)
    IF EXISTS(
        SELECT 1 FROM notifications n
        WHERE n.user_id = target_user_id
        AND n.type = notification_type
        AND n.actor_id = actor_id
        AND n.post_id = post_id
        AND n.comment_id = comment_id
        AND n.created_at > NOW() - INTERVAL '5 minutes'
    ) THEN
        RETURN NULL;
    END IF;
    
    -- Create the notification
    INSERT INTO notifications (
        user_id, type, title, message, actor_id, post_id, comment_id, 
        conversation_id, metadata
    ) VALUES (
        target_user_id, notification_type, title, message, actor_id, 
        post_id, comment_id, conversation_id, metadata
    ) RETURNING id INTO notification_id;
    
    RETURN notification_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to mark notifications as read
CREATE OR REPLACE FUNCTION mark_notifications_read(
    target_user_id UUID,
    notification_ids UUID[] DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    updated_count INTEGER;
BEGIN
    IF notification_ids IS NULL THEN
        -- Mark all unread notifications as read
        UPDATE notifications 
        SET is_read = TRUE, read_at = NOW()
        WHERE user_id = target_user_id AND NOT is_read;
        GET DIAGNOSTICS updated_count = ROW_COUNT;
    ELSE
        -- Mark specific notifications as read
        UPDATE notifications 
        SET is_read = TRUE, read_at = NOW()
        WHERE user_id = target_user_id 
        AND id = ANY(notification_ids) 
        AND NOT is_read;
        GET DIAGNOSTICS updated_count = ROW_COUNT;
    END IF;
    
    RETURN updated_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- MESSAGING FUNCTIONS
-- =====================================================

-- Function to create or get conversation between users
CREATE OR REPLACE FUNCTION get_or_create_conversation(
    user1_id UUID,
    user2_id UUID
)
RETURNS UUID AS $$
DECLARE
    conversation_id UUID;
BEGIN
    -- Check if conversation already exists
    SELECT c.id INTO conversation_id
    FROM conversations c
    JOIN conversation_participants cp1 ON c.id = cp1.conversation_id
    JOIN conversation_participants cp2 ON c.id = cp2.conversation_id
    WHERE 
        c.is_group = FALSE
        AND cp1.user_id = user1_id AND cp1.left_at IS NULL
        AND cp2.user_id = user2_id AND cp2.left_at IS NULL
        AND (
            SELECT COUNT(*) FROM conversation_participants cp
            WHERE cp.conversation_id = c.id AND cp.left_at IS NULL
        ) = 2;
    
    IF conversation_id IS NOT NULL THEN
        RETURN conversation_id;
    END IF;
    
    -- Create new conversation
    INSERT INTO conversations (is_group, created_by)
    VALUES (FALSE, user1_id)
    RETURNING id INTO conversation_id;
    
    -- Add participants
    INSERT INTO conversation_participants (conversation_id, user_id)
    VALUES 
        (conversation_id, user1_id),
        (conversation_id, user2_id);
    
    RETURN conversation_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get conversation messages with pagination
CREATE OR REPLACE FUNCTION get_conversation_messages(
    conversation_id UUID,
    requesting_user_id UUID,
    limit_count INTEGER DEFAULT 50,
    before_message_id UUID DEFAULT NULL
)
RETURNS TABLE(
    message_id UUID,
    sender_id UUID,
    sender_username VARCHAR(50),
    sender_avatar_url VARCHAR(500),
    content TEXT,
    message_type message_type,
    media_url VARCHAR(500),
    reply_to_message_id UUID,
    is_edited BOOLEAN,
    created_at TIMESTAMP WITH TIME ZONE,
    read_by_users JSONB
) AS $$
BEGIN
    -- Verify user is participant in conversation
    IF NOT EXISTS(
        SELECT 1 FROM conversation_participants cp
        WHERE cp.conversation_id = get_conversation_messages.conversation_id
        AND cp.user_id = requesting_user_id
        AND cp.left_at IS NULL
    ) THEN
        RAISE EXCEPTION 'User is not a participant in this conversation';
    END IF;
    
    RETURN QUERY
    SELECT 
        m.id,
        m.sender_id,
        u.username,
        u.avatar_url,
        m.content,
        m.message_type,
        m.media_url,
        m.reply_to_message_id,
        m.is_edited,
        m.created_at,
        -- Get read receipts for this message
        COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'user_id', mrr.user_id,
                    'read_at', mrr.read_at
                )
            ) FILTER (WHERE mrr.user_id IS NOT NULL),
            '[]'::jsonb
        ) AS read_by_users
    FROM messages m
    LEFT JOIN users u ON m.sender_id = u.id
    LEFT JOIN message_read_receipts mrr ON m.id = mrr.message_id
    WHERE 
        m.conversation_id = get_conversation_messages.conversation_id
        AND NOT m.is_deleted
        AND (
            before_message_id IS NULL OR 
            m.created_at < (
                SELECT created_at FROM messages 
                WHERE id = before_message_id
            )
        )
    GROUP BY m.id, m.sender_id, u.username, u.avatar_url, m.content, 
             m.message_type, m.media_url, m.reply_to_message_id, 
             m.is_edited, m.created_at
    ORDER BY m.created_at DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =====================================================
-- ANALYTICS FUNCTIONS
-- =====================================================

-- Function to track user activity
CREATE OR REPLACE FUNCTION track_user_activity(
    target_user_id UUID,
    activity_type VARCHAR(50),
    entity_type VARCHAR(50) DEFAULT NULL,
    entity_id UUID DEFAULT NULL,
    ip_address INET DEFAULT NULL,
    user_agent TEXT DEFAULT NULL,
    metadata JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    activity_id UUID;
BEGIN
    INSERT INTO user_activities (
        user_id, activity_type, entity_type, entity_id,
        ip_address, user_agent, metadata
    ) VALUES (
        target_user_id, activity_type, entity_type, entity_id,
        ip_address, user_agent, metadata
    ) RETURNING id INTO activity_id;
    
    RETURN activity_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user engagement statistics
CREATE OR REPLACE FUNCTION get_user_engagement_stats(
    target_user_id UUID,
    time_period INTERVAL DEFAULT '30 days'
)
RETURNS TABLE(
    posts_created INTEGER,
    comments_made INTEGER,
    likes_given INTEGER,
    messages_sent INTEGER,
    total_likes_received INTEGER,
    total_comments_received INTEGER,
    follower_growth INTEGER,
    avg_engagement_rate REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        -- Posts created
        (SELECT COUNT(*)::INTEGER FROM posts p 
         WHERE p.author_id = target_user_id 
         AND p.created_at > NOW() - time_period
         AND p.deleted_at IS NULL),
        
        -- Comments made
        (SELECT COUNT(*)::INTEGER FROM post_comments pc 
         WHERE pc.author_id = target_user_id 
         AND pc.created_at > NOW() - time_period
         AND pc.deleted_at IS NULL),
        
        -- Likes given
        (SELECT COUNT(*)::INTEGER FROM post_likes pl 
         WHERE pl.user_id = target_user_id 
         AND pl.created_at > NOW() - time_period),
        
        -- Messages sent
        (SELECT COUNT(*)::INTEGER FROM messages m 
         WHERE m.sender_id = target_user_id 
         AND m.created_at > NOW() - time_period
         AND NOT m.is_deleted),
        
        -- Total likes received
        (SELECT COUNT(*)::INTEGER FROM post_likes pl 
         JOIN posts p ON pl.post_id = p.id
         WHERE p.author_id = target_user_id 
         AND pl.created_at > NOW() - time_period),
        
        -- Total comments received
        (SELECT COUNT(*)::INTEGER FROM post_comments pc 
         JOIN posts p ON pc.post_id = p.id
         WHERE p.author_id = target_user_id 
         AND pc.created_at > NOW() - time_period
         AND pc.deleted_at IS NULL),
        
        -- Follower growth
        (SELECT COUNT(*)::INTEGER FROM user_relationships ur 
         WHERE ur.following_id = target_user_id 
         AND ur.relationship_type = 'follow'
         AND ur.created_at > NOW() - time_period),
        
        -- Average engagement rate
        (SELECT 
            CASE 
                WHEN COUNT(p.id) > 0 THEN
                    (AVG(p.likes_count + p.comments_count)::REAL / 
                     GREATEST((SELECT followers_count FROM users WHERE id = target_user_id), 1))
                ELSE 0.0
            END
         FROM posts p 
         WHERE p.author_id = target_user_id 
         AND p.created_at > NOW() - time_period
         AND p.deleted_at IS NULL);
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =====================================================
-- CONTENT MODERATION FUNCTIONS
-- =====================================================

-- Function to check content for moderation
CREATE OR REPLACE FUNCTION check_content_moderation(
    content TEXT,
    content_type VARCHAR(50) DEFAULT 'post'
)
RETURNS TABLE(
    requires_moderation BOOLEAN,
    confidence_score REAL,
    detected_issues TEXT[],
    auto_action VARCHAR(50)
) AS $$
DECLARE
    spam_keywords TEXT[] := ARRAY['spam', 'buy now', 'click here', 'free money'];
    hate_speech_keywords TEXT[] := ARRAY['hate', 'violence']; -- Simplified for demo
    content_lower TEXT := LOWER(content);
    issue_count INTEGER := 0;
    issues TEXT[] := ARRAY[]::TEXT[];
    confidence REAL := 0.0;
BEGIN
    -- Check for spam keywords
    IF EXISTS(SELECT 1 FROM unnest(spam_keywords) AS keyword WHERE content_lower LIKE '%' || keyword || '%') THEN
        issues := array_append(issues, 'potential_spam');
        issue_count := issue_count + 1;
        confidence := confidence + 0.3;
    END IF;
    
    -- Check for hate speech keywords
    IF EXISTS(SELECT 1 FROM unnest(hate_speech_keywords) AS keyword WHERE content_lower LIKE '%' || keyword || '%') THEN
        issues := array_append(issues, 'hate_speech');
        issue_count := issue_count + 1;
        confidence := confidence + 0.5;
    END IF;
    
    -- Check content length for spam (very short or very long)
    IF LENGTH(content) < 10 OR LENGTH(content) > 5000 THEN
        issues := array_append(issues, 'suspicious_length');
        confidence := confidence + 0.1;
    END IF;
    
    -- Check for excessive capitalization
    IF LENGTH(REGEXP_REPLACE(content, '[^A-Z]', '', 'g')) > LENGTH(content) * 0.7 THEN
        issues := array_append(issues, 'excessive_caps');
        confidence := confidence + 0.2;
    END IF;
    
    -- Determine auto action
    RETURN QUERY SELECT 
        issue_count > 0,
        LEAST(confidence, 1.0),
        issues,
        CASE 
            WHEN confidence > 0.8 THEN 'auto_hide'
            WHEN confidence > 0.5 THEN 'flag_for_review'
            WHEN confidence > 0.3 THEN 'warn_user'
            ELSE 'no_action'
        END;
END;
$$ LANGUAGE plpgsql STABLE;

-- =====================================================
-- PERFORMANCE MONITORING FUNCTIONS
-- =====================================================

-- Function to get database performance metrics
CREATE OR REPLACE FUNCTION get_db_performance_metrics()
RETURNS TABLE(
    metric_name TEXT,
    metric_value REAL,
    metric_unit TEXT,
    collected_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'active_connections'::TEXT,
        (SELECT COUNT(*)::REAL FROM pg_stat_activity WHERE state = 'active'),
        'count'::TEXT,
        NOW()
    UNION ALL
    SELECT 
        'idle_connections'::TEXT,
        (SELECT COUNT(*)::REAL FROM pg_stat_activity WHERE state = 'idle'),
        'count'::TEXT,
        NOW()
    UNION ALL
    SELECT 
        'total_users'::TEXT,
        (SELECT COUNT(*)::REAL FROM users WHERE status = 'active'),
        'count'::TEXT,
        NOW()
    UNION ALL
    SELECT 
        'total_posts'::TEXT,
        (SELECT COUNT(*)::REAL FROM posts WHERE deleted_at IS NULL),
        'count'::TEXT,
        NOW()
    UNION ALL
    SELECT 
        'posts_last_24h'::TEXT,
        (SELECT COUNT(*)::REAL FROM posts WHERE created_at > NOW() - INTERVAL '24 hours'),
        'count'::TEXT,
        NOW()
    UNION ALL
    SELECT 
        'active_sessions'::TEXT,
        (SELECT COUNT(*)::REAL FROM user_sessions WHERE is_active = TRUE AND expires_at > NOW()),
        'count'::TEXT,
        NOW();
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =====================================================
-- UTILITY FUNCTIONS
-- =====================================================

-- Function to generate username suggestions
CREATE OR REPLACE FUNCTION generate_username_suggestions(
    base_username VARCHAR(50),
    suggestion_count INTEGER DEFAULT 5
)
RETURNS TEXT[] AS $$
DECLARE
    suggestions TEXT[] := ARRAY[]::TEXT[];
    counter INTEGER := 1;
    current_suggestion TEXT;
BEGIN
    -- Add base username if available
    IF NOT EXISTS(SELECT 1 FROM users WHERE username = base_username) THEN
        suggestions := array_append(suggestions, base_username);
    END IF;
    
    -- Generate numbered variations
    WHILE array_length(suggestions, 1) < suggestion_count AND counter <= 999 LOOP
        current_suggestion := base_username || counter::TEXT;
        
        IF NOT EXISTS(SELECT 1 FROM users WHERE username = current_suggestion) THEN
            suggestions := array_append(suggestions, current_suggestion);
        END IF;
        
        counter := counter + 1;
    END LOOP;
    
    -- Generate random suffix variations if needed
    WHILE array_length(suggestions, 1) < suggestion_count LOOP
        current_suggestion := base_username || '_' || (RANDOM() * 9999)::INTEGER::TEXT;
        
        IF NOT EXISTS(SELECT 1 FROM users WHERE username = current_suggestion) 
           AND NOT (current_suggestion = ANY(suggestions)) THEN
            suggestions := array_append(suggestions, current_suggestion);
        END IF;
    END LOOP;
    
    RETURN suggestions;
END;
$$ LANGUAGE plpgsql STABLE;

-- Function to clean up old data
CREATE OR REPLACE FUNCTION cleanup_old_data()
RETURNS TABLE(
    table_name TEXT,
    rows_deleted INTEGER
) AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Clean up old user activities (older than 6 months)
    DELETE FROM user_activities WHERE created_at < NOW() - INTERVAL '6 months';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN QUERY SELECT 'user_activities'::TEXT, deleted_count;
    
    -- Clean up old notifications (older than 3 months)
    DELETE FROM notifications WHERE created_at < NOW() - INTERVAL '3 months';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN QUERY SELECT 'notifications'::TEXT, deleted_count;
    
    -- Clean up expired sessions
    DELETE FROM user_sessions WHERE expires_at < NOW() OR (NOT is_active AND last_used_at < NOW() - INTERVAL '7 days');
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN QUERY SELECT 'user_sessions'::TEXT, deleted_count;
    
    -- Clean up old system metrics (older than 30 days)
    DELETE FROM system_metrics WHERE created_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN QUERY SELECT 'system_metrics'::TEXT, deleted_count;
    
    -- Clean up old trending topics (older than 7 days)
    DELETE FROM trending_topics WHERE period_end < NOW() - INTERVAL '7 days';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN QUERY SELECT 'trending_topics'::TEXT, deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Comments for documentation
COMMENT ON FUNCTION get_user_feed(UUID, INTEGER, INTEGER, TEXT) IS 'Generate personalized feed for user with privacy and blocking filters';
COMMENT ON FUNCTION get_trending_hashtags(INTEGER, INTERVAL) IS 'Get trending hashtags based on recent usage patterns';
COMMENT ON FUNCTION search_content(TEXT, TEXT[], UUID, INTEGER) IS 'Comprehensive search across users, posts, and hashtags with relevance scoring';
COMMENT ON FUNCTION create_notification(UUID, notification_type, VARCHAR, TEXT, UUID, UUID, UUID, UUID, JSONB) IS 'Create notification with user preference checking and spam prevention';
COMMENT ON FUNCTION get_or_create_conversation(UUID, UUID) IS 'Get existing conversation between two users or create new one';
COMMENT ON FUNCTION track_user_activity(UUID, VARCHAR, VARCHAR, UUID, INET, TEXT, JSONB) IS 'Track user activity for analytics and behavior analysis';
COMMENT ON FUNCTION check_content_moderation(TEXT, VARCHAR) IS 'Analyze content for potential moderation issues using keyword detection';
COMMENT ON FUNCTION cleanup_old_data() IS 'Clean up old data to maintain database performance';
