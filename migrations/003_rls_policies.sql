-- ChitLaq M1 MVP - Row Level Security Policies
-- Comprehensive RLS implementation for multi-tenant security
-- Generated by PROMPT 1.3 - Database Schema & Migrations

-- Enable Row Level Security on all user-data tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_relationships ENABLE ROW LEVEL SECURITY;
ALTER TABLE friend_suggestions ENABLE ROW LEVEL SECURITY;
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE post_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE post_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE comment_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE post_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE message_read_receipts ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_moderation_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_activities ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_interests ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_action_logs ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- UTILITY FUNCTIONS FOR RLS
-- =====================================================

-- Function to get current user ID from JWT or session
CREATE OR REPLACE FUNCTION auth.user_id() 
RETURNS UUID AS $$
    SELECT COALESCE(
        nullif(current_setting('request.jwt.claims', true)::json->>'user_id', '')::uuid,
        nullif(current_setting('app.current_user_id', true), '')::uuid
    );
$$ LANGUAGE SQL STABLE;

-- Function to check if current user is admin
CREATE OR REPLACE FUNCTION auth.is_admin() 
RETURNS BOOLEAN AS $$
    SELECT EXISTS(
        SELECT 1 FROM users 
        WHERE id = auth.user_id() 
        AND is_admin = true 
        AND status = 'active'
    );
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

-- Function to check if current user is moderator
CREATE OR REPLACE FUNCTION auth.is_moderator() 
RETURNS BOOLEAN AS $$
    SELECT EXISTS(
        SELECT 1 FROM users 
        WHERE id = auth.user_id() 
        AND (is_admin = true OR id IN (
            SELECT user_id FROM user_moderation_history 
            WHERE action IN ('warn', 'suspend', 'delete_content', 'ban')
            AND created_at > NOW() - INTERVAL '30 days'
        ))
        AND status = 'active'
    );
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

-- Function to check if user A can see user B's content
CREATE OR REPLACE FUNCTION auth.can_see_user_content(target_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    current_user_id UUID := auth.user_id();
    target_user_private BOOLEAN;
    is_following BOOLEAN;
    is_blocked BOOLEAN;
BEGIN
    -- Admin can see everything
    IF auth.is_admin() THEN
        RETURN TRUE;
    END IF;
    
    -- User can always see their own content
    IF current_user_id = target_user_id THEN
        RETURN TRUE;
    END IF;
    
    -- Check if target user is private
    SELECT is_private INTO target_user_private 
    FROM users 
    WHERE id = target_user_id AND status = 'active';
    
    -- If user not found or not active, deny access
    IF target_user_private IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Check if current user is blocked by target user
    SELECT EXISTS(
        SELECT 1 FROM user_relationships 
        WHERE follower_id = target_user_id 
        AND following_id = current_user_id 
        AND relationship_type = 'block'
    ) INTO is_blocked;
    
    IF is_blocked THEN
        RETURN FALSE;
    END IF;
    
    -- If target user is not private, content is visible
    IF NOT target_user_private THEN
        RETURN TRUE;
    END IF;
    
    -- For private users, check if following
    SELECT EXISTS(
        SELECT 1 FROM user_relationships 
        WHERE follower_id = current_user_id 
        AND following_id = target_user_id 
        AND relationship_type = 'follow'
    ) INTO is_following;
    
    RETURN is_following;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to check if user can see specific post based on privacy
CREATE OR REPLACE FUNCTION auth.can_see_post(post_author_id UUID, post_privacy privacy_level)
RETURNS BOOLEAN AS $$
DECLARE
    current_user_id UUID := auth.user_id();
BEGIN
    -- Admin can see everything
    IF auth.is_admin() THEN
        RETURN TRUE;
    END IF;
    
    -- User can always see their own posts
    IF current_user_id = post_author_id THEN
        RETURN TRUE;
    END IF;
    
    -- Public posts are visible to everyone
    IF post_privacy = 'public' THEN
        RETURN auth.can_see_user_content(post_author_id);
    END IF;
    
    -- Followers posts require following relationship
    IF post_privacy = 'followers' THEN
        RETURN auth.can_see_user_content(post_author_id) AND EXISTS(
            SELECT 1 FROM user_relationships 
            WHERE follower_id = current_user_id 
            AND following_id = post_author_id 
            AND relationship_type = 'follow'
        );
    END IF;
    
    -- Private posts are only visible to author
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =====================================================
-- USER TABLE POLICIES
-- =====================================================

-- Users can view their own profile and active public profiles
CREATE POLICY "users_select_policy" ON users
    FOR SELECT USING (
        id = auth.user_id() OR 
        (status = 'active' AND (
            NOT is_private OR 
            auth.is_admin() OR
            EXISTS(
                SELECT 1 FROM user_relationships 
                WHERE follower_id = auth.user_id() 
                AND following_id = users.id 
                AND relationship_type = 'follow'
            )
        ))
    );

-- Users can only update their own profile
CREATE POLICY "users_update_policy" ON users
    FOR UPDATE USING (id = auth.user_id())
    WITH CHECK (id = auth.user_id());

-- Users can insert their own profile (registration)
CREATE POLICY "users_insert_policy" ON users
    FOR INSERT WITH CHECK (id = auth.user_id() OR auth.user_id() IS NULL);

-- Only admins can delete users
CREATE POLICY "users_delete_policy" ON users
    FOR DELETE USING (auth.is_admin());

-- =====================================================
-- USER SESSIONS POLICIES
-- =====================================================

CREATE POLICY "user_sessions_policy" ON user_sessions
    FOR ALL USING (user_id = auth.user_id());

-- =====================================================
-- SOCIAL RELATIONSHIPS POLICIES
-- =====================================================

-- Users can view relationships involving them or public relationships
CREATE POLICY "user_relationships_select_policy" ON user_relationships
    FOR SELECT USING (
        follower_id = auth.user_id() OR 
        following_id = auth.user_id() OR
        (relationship_type = 'follow' AND auth.can_see_user_content(following_id))
    );

-- Users can create relationships where they are the follower
CREATE POLICY "user_relationships_insert_policy" ON user_relationships
    FOR INSERT WITH CHECK (follower_id = auth.user_id());

-- Users can delete their own relationships
CREATE POLICY "user_relationships_delete_policy" ON user_relationships
    FOR DELETE USING (follower_id = auth.user_id());

-- =====================================================
-- FRIEND SUGGESTIONS POLICIES
-- =====================================================

CREATE POLICY "friend_suggestions_policy" ON friend_suggestions
    FOR ALL USING (user_id = auth.user_id());

-- =====================================================
-- POSTS POLICIES
-- =====================================================

-- Users can view posts based on privacy settings
CREATE POLICY "posts_select_policy" ON posts
    FOR SELECT USING (
        deleted_at IS NULL AND
        NOT is_hidden AND
        auth.can_see_post(author_id, privacy_level)
    );

-- Users can create their own posts
CREATE POLICY "posts_insert_policy" ON posts
    FOR INSERT WITH CHECK (author_id = auth.user_id());

-- Users can update their own posts
CREATE POLICY "posts_update_policy" ON posts
    FOR UPDATE USING (author_id = auth.user_id())
    WITH CHECK (author_id = auth.user_id());

-- Users can delete their own posts, admins can delete any
CREATE POLICY "posts_delete_policy" ON posts
    FOR DELETE USING (
        author_id = auth.user_id() OR 
        auth.is_admin()
    );

-- =====================================================
-- POST ENGAGEMENT POLICIES
-- =====================================================

-- Post likes: users can view likes on posts they can see
CREATE POLICY "post_likes_select_policy" ON post_likes
    FOR SELECT USING (
        EXISTS(
            SELECT 1 FROM posts 
            WHERE id = post_likes.post_id 
            AND auth.can_see_post(author_id, privacy_level)
        )
    );

-- Users can create/delete their own likes
CREATE POLICY "post_likes_insert_policy" ON post_likes
    FOR INSERT WITH CHECK (user_id = auth.user_id());

CREATE POLICY "post_likes_delete_policy" ON post_likes
    FOR DELETE USING (user_id = auth.user_id());

-- Post comments: similar to posts but with visibility based on parent post
CREATE POLICY "post_comments_select_policy" ON post_comments
    FOR SELECT USING (
        deleted_at IS NULL AND
        NOT is_hidden AND
        EXISTS(
            SELECT 1 FROM posts 
            WHERE id = post_comments.post_id 
            AND auth.can_see_post(author_id, privacy_level)
        )
    );

CREATE POLICY "post_comments_insert_policy" ON post_comments
    FOR INSERT WITH CHECK (
        author_id = auth.user_id() AND
        EXISTS(
            SELECT 1 FROM posts 
            WHERE id = post_comments.post_id 
            AND auth.can_see_post(author_id, privacy_level)
        )
    );

CREATE POLICY "post_comments_update_policy" ON post_comments
    FOR UPDATE USING (author_id = auth.user_id())
    WITH CHECK (author_id = auth.user_id());

CREATE POLICY "post_comments_delete_policy" ON post_comments
    FOR DELETE USING (
        author_id = auth.user_id() OR 
        auth.is_admin()
    );

-- Comment likes
CREATE POLICY "comment_likes_select_policy" ON comment_likes
    FOR SELECT USING (
        EXISTS(
            SELECT 1 FROM post_comments pc
            JOIN posts p ON pc.post_id = p.id
            WHERE pc.id = comment_likes.comment_id 
            AND auth.can_see_post(p.author_id, p.privacy_level)
        )
    );

CREATE POLICY "comment_likes_insert_policy" ON comment_likes
    FOR INSERT WITH CHECK (user_id = auth.user_id());

CREATE POLICY "comment_likes_delete_policy" ON comment_likes
    FOR DELETE USING (user_id = auth.user_id());

-- Post shares
CREATE POLICY "post_shares_select_policy" ON post_shares
    FOR SELECT USING (
        user_id = auth.user_id() OR
        (privacy_level = 'public' AND EXISTS(
            SELECT 1 FROM posts 
            WHERE id = post_shares.original_post_id 
            AND auth.can_see_post(author_id, privacy_level)
        ))
    );

CREATE POLICY "post_shares_insert_policy" ON post_shares
    FOR INSERT WITH CHECK (
        user_id = auth.user_id() AND
        EXISTS(
            SELECT 1 FROM posts 
            WHERE id = post_shares.original_post_id 
            AND auth.can_see_post(author_id, privacy_level)
        )
    );

CREATE POLICY "post_shares_delete_policy" ON post_shares
    FOR DELETE USING (user_id = auth.user_id());

-- =====================================================
-- MESSAGING POLICIES
-- =====================================================

-- Conversations: users can only see conversations they participate in
CREATE POLICY "conversations_policy" ON conversations
    FOR ALL USING (
        EXISTS(
            SELECT 1 FROM conversation_participants 
            WHERE conversation_id = conversations.id 
            AND user_id = auth.user_id()
            AND left_at IS NULL
        )
    );

-- Conversation participants
CREATE POLICY "conversation_participants_select_policy" ON conversation_participants
    FOR SELECT USING (
        user_id = auth.user_id() OR
        EXISTS(
            SELECT 1 FROM conversation_participants cp2
            WHERE cp2.conversation_id = conversation_participants.conversation_id 
            AND cp2.user_id = auth.user_id()
            AND cp2.left_at IS NULL
        )
    );

CREATE POLICY "conversation_participants_insert_policy" ON conversation_participants
    FOR INSERT WITH CHECK (
        user_id = auth.user_id() OR
        (auth.user_id() IN (
            SELECT cp.user_id FROM conversation_participants cp
            WHERE cp.conversation_id = conversation_participants.conversation_id
            AND cp.is_admin = true
            AND cp.left_at IS NULL
        ))
    );

CREATE POLICY "conversation_participants_update_policy" ON conversation_participants
    FOR UPDATE USING (
        user_id = auth.user_id() OR
        (auth.user_id() IN (
            SELECT cp.user_id FROM conversation_participants cp
            WHERE cp.conversation_id = conversation_participants.conversation_id
            AND cp.is_admin = true
            AND cp.left_at IS NULL
        ))
    );

-- Messages
CREATE POLICY "messages_select_policy" ON messages
    FOR SELECT USING (
        NOT is_deleted AND
        EXISTS(
            SELECT 1 FROM conversation_participants 
            WHERE conversation_id = messages.conversation_id 
            AND user_id = auth.user_id()
            AND left_at IS NULL
        )
    );

CREATE POLICY "messages_insert_policy" ON messages
    FOR INSERT WITH CHECK (
        sender_id = auth.user_id() AND
        EXISTS(
            SELECT 1 FROM conversation_participants 
            WHERE conversation_id = messages.conversation_id 
            AND user_id = auth.user_id()
            AND left_at IS NULL
        )
    );

CREATE POLICY "messages_update_policy" ON messages
    FOR UPDATE USING (sender_id = auth.user_id())
    WITH CHECK (sender_id = auth.user_id());

CREATE POLICY "messages_delete_policy" ON messages
    FOR DELETE USING (
        sender_id = auth.user_id() OR
        auth.is_admin()
    );

-- Message read receipts
CREATE POLICY "message_read_receipts_policy" ON message_read_receipts
    FOR ALL USING (
        user_id = auth.user_id() AND
        EXISTS(
            SELECT 1 FROM messages m
            JOIN conversation_participants cp ON m.conversation_id = cp.conversation_id
            WHERE m.id = message_read_receipts.message_id 
            AND cp.user_id = auth.user_id()
            AND cp.left_at IS NULL
        )
    );

-- =====================================================
-- NOTIFICATIONS POLICIES
-- =====================================================

CREATE POLICY "notifications_policy" ON notifications
    FOR ALL USING (user_id = auth.user_id());

CREATE POLICY "notification_preferences_policy" ON notification_preferences
    FOR ALL USING (user_id = auth.user_id());

-- =====================================================
-- REPORTING AND MODERATION POLICIES
-- =====================================================

-- Reports: users can see their own reports, moderators can see all
CREATE POLICY "reports_select_policy" ON reports
    FOR SELECT USING (
        reporter_id = auth.user_id() OR
        reported_user_id = auth.user_id() OR
        auth.is_moderator()
    );

CREATE POLICY "reports_insert_policy" ON reports
    FOR INSERT WITH CHECK (reporter_id = auth.user_id());

CREATE POLICY "reports_update_policy" ON reports
    FOR UPDATE USING (auth.is_moderator())
    WITH CHECK (auth.is_moderator());

-- Moderation history: users can see their own, moderators can see all
CREATE POLICY "user_moderation_history_select_policy" ON user_moderation_history
    FOR SELECT USING (
        user_id = auth.user_id() OR
        auth.is_moderator()
    );

CREATE POLICY "user_moderation_history_insert_policy" ON user_moderation_history
    FOR INSERT WITH CHECK (auth.is_moderator());

-- =====================================================
-- ANALYTICS POLICIES
-- =====================================================

-- User activities: users can see their own, admins can see all
CREATE POLICY "user_activities_select_policy" ON user_activities
    FOR SELECT USING (
        user_id = auth.user_id() OR
        auth.is_admin()
    );

CREATE POLICY "user_activities_insert_policy" ON user_activities
    FOR INSERT WITH CHECK (user_id = auth.user_id() OR auth.user_id() IS NULL);

-- User interests
CREATE POLICY "user_interests_policy" ON user_interests
    FOR ALL USING (user_id = auth.user_id());

-- =====================================================
-- ADMIN POLICIES
-- =====================================================

CREATE POLICY "admin_action_logs_select_policy" ON admin_action_logs
    FOR SELECT USING (auth.is_admin());

CREATE POLICY "admin_action_logs_insert_policy" ON admin_action_logs
    FOR INSERT WITH CHECK (
        admin_id = auth.user_id() AND 
        auth.is_admin()
    );

-- =====================================================
-- HASHTAG POLICIES (No RLS - Public Data)
-- =====================================================

-- Hashtags are public data, no RLS needed
-- post_hashtags inherit security from posts table

-- =====================================================
-- SYSTEM TABLES (No RLS)
-- =====================================================

-- Tables that don't need RLS:
-- - hashtags (public data)
-- - university_domains (public configuration)
-- - system_config (handled by application logic)
-- - system_metrics (admin access only via application)
-- - trending_topics (public data)

-- =====================================================
-- SECURITY FUNCTIONS FOR APPLICATION USE
-- =====================================================

-- Function to check if user can perform action on post
CREATE OR REPLACE FUNCTION auth.can_interact_with_post(post_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    post_author UUID;
    post_privacy privacy_level;
BEGIN
    SELECT author_id, privacy_level INTO post_author, post_privacy
    FROM posts 
    WHERE id = post_id AND deleted_at IS NULL AND NOT is_hidden;
    
    IF post_author IS NULL THEN
        RETURN FALSE;
    END IF;
    
    RETURN auth.can_see_post(post_author, post_privacy);
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to check if user can send message to another user
CREATE OR REPLACE FUNCTION auth.can_message_user(target_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    current_user_id UUID := auth.user_id();
    is_blocked BOOLEAN;
BEGIN
    -- Can't message yourself
    IF current_user_id = target_user_id THEN
        RETURN FALSE;
    END IF;
    
    -- Check if blocked by target user
    SELECT EXISTS(
        SELECT 1 FROM user_relationships 
        WHERE follower_id = target_user_id 
        AND following_id = current_user_id 
        AND relationship_type = 'block'
    ) INTO is_blocked;
    
    RETURN NOT is_blocked;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to get user's blocked users (for filtering)
CREATE OR REPLACE FUNCTION auth.get_blocked_users()
RETURNS UUID[] AS $$
    SELECT ARRAY_AGG(following_id) 
    FROM user_relationships 
    WHERE follower_id = auth.user_id() 
    AND relationship_type = 'block';
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

-- Function to get users who blocked current user (for filtering)
CREATE OR REPLACE FUNCTION auth.get_users_who_blocked_me()
RETURNS UUID[] AS $$
    SELECT ARRAY_AGG(follower_id) 
    FROM user_relationships 
    WHERE following_id = auth.user_id() 
    AND relationship_type = 'block';
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

-- =====================================================
-- PERFORMANCE OPTIMIZATION FOR RLS
-- =====================================================

-- Create indexes to support RLS policies
CREATE INDEX CONCURRENTLY idx_rls_user_relationships_block_check 
ON user_relationships(following_id, follower_id) 
WHERE relationship_type = 'block';

CREATE INDEX CONCURRENTLY idx_rls_user_relationships_follow_check 
ON user_relationships(follower_id, following_id) 
WHERE relationship_type = 'follow';

CREATE INDEX CONCURRENTLY idx_rls_users_privacy_status 
ON users(id, is_private, status) 
WHERE status = 'active';

CREATE INDEX CONCURRENTLY idx_rls_posts_author_privacy 
ON posts(author_id, privacy_level, deleted_at, is_hidden) 
WHERE deleted_at IS NULL AND NOT is_hidden;

CREATE INDEX CONCURRENTLY idx_rls_conversation_participants_active 
ON conversation_participants(conversation_id, user_id, left_at) 
WHERE left_at IS NULL;

-- =====================================================
-- RLS BYPASS FOR SYSTEM OPERATIONS
-- =====================================================

-- Create a system user role that can bypass RLS for maintenance
CREATE ROLE chitlaq_system;
ALTER ROLE chitlaq_system BYPASSRLS;

-- Grant necessary permissions to system role
GRANT USAGE ON SCHEMA public TO chitlaq_system;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO chitlaq_system;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO chitlaq_system;

-- Comments for documentation
COMMENT ON FUNCTION auth.user_id() IS 'Get current authenticated user ID from JWT or session';
COMMENT ON FUNCTION auth.is_admin() IS 'Check if current user has admin privileges';
COMMENT ON FUNCTION auth.is_moderator() IS 'Check if current user has moderation privileges';
COMMENT ON FUNCTION auth.can_see_user_content(UUID) IS 'Check if current user can view target user content based on privacy settings';
COMMENT ON FUNCTION auth.can_see_post(UUID, privacy_level) IS 'Check if current user can view specific post based on privacy level';
COMMENT ON FUNCTION auth.can_interact_with_post(UUID) IS 'Check if current user can like/comment on specific post';
COMMENT ON FUNCTION auth.can_message_user(UUID) IS 'Check if current user can send messages to target user';
COMMENT ON FUNCTION auth.get_blocked_users() IS 'Get array of user IDs blocked by current user';
COMMENT ON FUNCTION auth.get_users_who_blocked_me() IS 'Get array of user IDs who blocked current user';
