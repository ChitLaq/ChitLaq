#!/usr/bin/env node

/**
 * ChitLaq M1 MVP - Integration Tests Suite
 * Generated by PROMPT 1.5 - CI/CD Pipeline & Automated Deployment
 * Senior DevOps Engineer - 15+ years CI/CD and release management experience
 * 
 * Comprehensive integration testing suite for all ChitLaq services
 * Includes API testing, database integration, and end-to-end workflows
 */

const { performance } = require('perf_hooks');
const fs = require('fs').promises;
const path = require('path');

// Test configuration
const CONFIG = {
  // Test environments
  ENVIRONMENTS: {
    local: {
      baseURL: 'http://localhost:3001',
      database: 'postgresql://postgres:postgres@localhost:5432/chitlaq_test',
      redis: 'redis://localhost:6379'
    },
    staging: {
      baseURL: 'https://staging.chitlaq.com',
      database: process.env.STAGING_DATABASE_URL,
      redis: process.env.STAGING_REDIS_URL
    },
    production: {
      baseURL: 'https://chitlaq.com',
      database: process.env.PRODUCTION_DATABASE_URL,
      redis: process.env.PRODUCTION_REDIS_URL
    }
  },
  
  // Test timeouts
  TIMEOUTS: {
    api: 10000,
    database: 5000,
    websocket: 15000,
    file: 30000
  },
  
  // Test data
  TEST_DATA: {
    universities: [
      'stanford.edu',
      'mit.edu',
      'harvard.edu',
      'berkeley.edu',
      'cmu.edu'
    ],
    sampleUsers: [
      {
        email: 'integration-test-1@stanford.edu',
        username: 'integrationtest1',
        password: 'IntegrationTest123!',
        firstName: 'Integration',
        lastName: 'Test',
        university: 'stanford.edu'
      },
      {
        email: 'integration-test-2@mit.edu',
        username: 'integrationtest2',
        password: 'IntegrationTest123!',
        firstName: 'Integration',
        lastName: 'Test',
        university: 'mit.edu'
      }
    ],
    samplePosts: [
      'This is a test post for integration testing.',
      'Another test post with #hashtag and @mention.',
      'Test post with emoji 🚀 and special characters!'
    ],
    sampleMessages: [
      'Hello, this is a test message.',
      'Integration test message with emoji 📱',
      'Test message with special characters: @#$%^&*()'
    ]
  }
};

// Test result collector
class TestResults {
  constructor() {
    this.results = {
      passed: 0,
      failed: 0,
      skipped: 0,
      total: 0,
      duration: 0,
      tests: []
    };
    this.startTime = performance.now();
  }

  addTest(name, status, duration, error = null) {
    this.results.tests.push({
      name,
      status,
      duration,
      error: error ? error.message : null,
      timestamp: new Date().toISOString()
    });

    this.results[status]++;
    this.results.total++;
  }

  getSummary() {
    this.results.duration = performance.now() - this.startTime;
    return {
      ...this.results,
      successRate: (this.results.passed / this.results.total) * 100
    };
  }

  async saveResults(filename) {
    const results = this.getSummary();
    await fs.writeFile(filename, JSON.stringify(results, null, 2));
    return results;
  }
}

// HTTP client for API testing
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.session = null;
    this.cookies = new Map();
  }

  async request(method, endpoint, data = null, headers = {}) {
    const startTime = performance.now();
    
    try {
      const url = `${this.baseURL}${endpoint}`;
      const options = {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        }
      };

      if (this.session) {
        options.headers.Authorization = `Bearer ${this.session.token}`;
      }

      // Add cookies
      if (this.cookies.size > 0) {
        options.headers.Cookie = Array.from(this.cookies.entries())
          .map(([key, value]) => `${key}=${value}`)
          .join('; ');
      }

      if (data) {
        options.body = JSON.stringify(data);
      }

      const response = await fetch(url, options);
      const responseTime = performance.now() - startTime;
      
      // Handle cookies
      const setCookieHeader = response.headers.get('set-cookie');
      if (setCookieHeader) {
        setCookieHeader.split(',').forEach(cookie => {
          const [keyValue] = cookie.split(';');
          const [key, value] = keyValue.split('=');
          this.cookies.set(key.trim(), value.trim());
        });
      }
      
      return {
        status: response.status,
        data: await response.json().catch(() => null),
        responseTime,
        success: response.ok,
        headers: Object.fromEntries(response.headers.entries())
      };
    } catch (error) {
      const responseTime = performance.now() - startTime;
      return {
        status: 0,
        data: null,
        responseTime,
        success: false,
        error: error.message
      };
    }
  }

  async login(email, password) {
    const response = await this.request('POST', '/api/auth/login', {
      email,
      password
    });
    
    if (response.success && response.data) {
      this.session = response.data;
    }
    
    return response;
  }

  async register(userData) {
    return await this.request('POST', '/api/auth/register', userData);
  }

  async logout() {
    const response = await this.request('POST', '/api/auth/logout');
    this.session = null;
    this.cookies.clear();
    return response;
  }

  async getProfile(userId) {
    return await this.request('GET', `/api/users/${userId}`);
  }

  async updateProfile(profileData) {
    return await this.request('PUT', '/api/users/profile', profileData);
  }

  async createPost(content) {
    return await this.request('POST', '/api/posts', { content });
  }

  async getPost(postId) {
    return await this.request('GET', `/api/posts/${postId}`);
  }

  async getFeed(page = 1) {
    return await this.request('GET', `/api/feed?page=${page}`);
  }

  async likePost(postId) {
    return await this.request('POST', `/api/posts/${postId}/like`);
  }

  async unlikePost(postId) {
    return await this.request('DELETE', `/api/posts/${postId}/like`);
  }

  async search(query) {
    return await this.request('GET', `/api/search?q=${encodeURIComponent(query)}`);
  }

  async followUser(userId) {
    return await this.request('POST', `/api/users/${userId}/follow`);
  }

  async unfollowUser(userId) {
    return await this.request('DELETE', `/api/users/${userId}/follow`);
  }

  async getFollowers(userId) {
    return await this.request('GET', `/api/users/${userId}/followers`);
  }

  async getFollowing(userId) {
    return await this.request('GET', `/api/users/${userId}/following`);
  }

  async sendMessage(recipientId, content) {
    return await this.request('POST', '/api/messages', {
      recipientId,
      content
    });
  }

  async getMessages(conversationId) {
    return await this.request('GET', `/api/messages/${conversationId}`);
  }

  async getConversations() {
    return await this.request('GET', '/api/messages/conversations');
  }
}

// Database client for integration testing
class DatabaseClient {
  constructor(connectionString) {
    this.connectionString = connectionString;
    this.client = null;
  }

  async connect() {
    // This would typically use a PostgreSQL client like 'pg'
    // For now, we'll simulate database operations
    this.client = { connected: true };
  }

  async disconnect() {
    if (this.client) {
      this.client = null;
    }
  }

  async query(sql, params = []) {
    // Simulate database query
    return {
      rows: [],
      rowCount: 0
    };
  }

  async getUserByEmail(email) {
    return await this.query('SELECT * FROM users WHERE email = $1', [email]);
  }

  async createUser(userData) {
    return await this.query(
      'INSERT INTO users (email, username, password_hash, first_name, last_name, university) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
      [userData.email, userData.username, userData.password, userData.firstName, userData.lastName, userData.university]
    );
  }

  async deleteUser(userId) {
    return await this.query('DELETE FROM users WHERE id = $1', [userId]);
  }

  async getPostById(postId) {
    return await this.query('SELECT * FROM posts WHERE id = $1', [postId]);
  }

  async createPost(postData) {
    return await this.query(
      'INSERT INTO posts (user_id, content, created_at) VALUES ($1, $2, NOW()) RETURNING *',
      [postData.userId, postData.content]
    );
  }

  async deletePost(postId) {
    return await this.query('DELETE FROM posts WHERE id = $1', [postId]);
  }
}

// WebSocket client for real-time testing
class WebSocketClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.ws = null;
    this.messages = [];
    this.connected = false;
  }

  async connect(token) {
    return new Promise((resolve, reject) => {
      const wsUrl = this.baseURL.replace('http', 'ws') + `/ws?token=${token}`;
      this.ws = new WebSocket(wsUrl);
      
      this.ws.onopen = () => {
        this.connected = true;
        resolve();
      };
      
      this.ws.onmessage = (event) => {
        this.messages.push({
          timestamp: performance.now(),
          data: JSON.parse(event.data)
        });
      };
      
      this.ws.onerror = (error) => {
        reject(error);
      };
      
      this.ws.onclose = () => {
        this.connected = false;
      };
    });
  }

  sendMessage(type, data) {
    if (this.connected) {
      this.ws.send(JSON.stringify({ type, data }));
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }

  waitForMessage(type, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const startTime = performance.now();
      
      const checkMessages = () => {
        const message = this.messages.find(msg => msg.data.type === type);
        if (message) {
          resolve(message);
          return;
        }
        
        if (performance.now() - startTime > timeout) {
          reject(new Error(`Timeout waiting for message type: ${type}`));
          return;
        }
        
        setTimeout(checkMessages, 100);
      };
      
      checkMessages();
    });
  }
}

// Test suite classes
class AuthIntegrationTests {
  constructor(apiClient, dbClient, results) {
    this.api = apiClient;
    this.db = dbClient;
    this.results = results;
  }

  async testUserRegistration() {
    const testName = 'User Registration';
    const startTime = performance.now();
    
    try {
      const user = CONFIG.TEST_DATA.sampleUsers[0];
      const response = await this.api.register(user);
      
      if (response.success && response.status === 201) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Registration failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testUserLogin() {
    const testName = 'User Login';
    const startTime = performance.now();
    
    try {
      const user = CONFIG.TEST_DATA.sampleUsers[0];
      const response = await this.api.login(user.email, user.password);
      
      if (response.success && response.data && response.data.token) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Login failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testUserLogout() {
    const testName = 'User Logout';
    const startTime = performance.now();
    
    try {
      const response = await this.api.logout();
      
      if (response.success) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Logout failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testInvalidCredentials() {
    const testName = 'Invalid Credentials';
    const startTime = performance.now();
    
    try {
      const response = await this.api.login('invalid@email.com', 'wrongpassword');
      
      if (!response.success && response.status === 401) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Expected 401 for invalid credentials, got: ${response.status}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async runAllTests() {
    console.log('Running Authentication Integration Tests...');
    await this.testUserRegistration();
    await this.testUserLogin();
    await this.testUserLogout();
    await this.testInvalidCredentials();
  }
}

class PostIntegrationTests {
  constructor(apiClient, dbClient, results) {
    this.api = apiClient;
    this.db = dbClient;
    this.results = results;
    this.createdPosts = [];
  }

  async testCreatePost() {
    const testName = 'Create Post';
    const startTime = performance.now();
    
    try {
      const content = CONFIG.TEST_DATA.samplePosts[0];
      const response = await this.api.createPost(content);
      
      if (response.success && response.data && response.data.id) {
        this.createdPosts.push(response.data.id);
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Post creation failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testGetPost() {
    const testName = 'Get Post';
    const startTime = performance.now();
    
    try {
      if (this.createdPosts.length === 0) {
        throw new Error('No posts created for testing');
      }
      
      const postId = this.createdPosts[0];
      const response = await this.api.getPost(postId);
      
      if (response.success && response.data && response.data.id === postId) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Get post failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testGetFeed() {
    const testName = 'Get Feed';
    const startTime = performance.now();
    
    try {
      const response = await this.api.getFeed(1);
      
      if (response.success && Array.isArray(response.data.posts)) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Get feed failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testLikePost() {
    const testName = 'Like Post';
    const startTime = performance.now();
    
    try {
      if (this.createdPosts.length === 0) {
        throw new Error('No posts created for testing');
      }
      
      const postId = this.createdPosts[0];
      const response = await this.api.likePost(postId);
      
      if (response.success) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Like post failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testUnlikePost() {
    const testName = 'Unlike Post';
    const startTime = performance.now();
    
    try {
      if (this.createdPosts.length === 0) {
        throw new Error('No posts created for testing');
      }
      
      const postId = this.createdPosts[0];
      const response = await this.api.unlikePost(postId);
      
      if (response.success) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Unlike post failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async runAllTests() {
    console.log('Running Post Integration Tests...');
    await this.testCreatePost();
    await this.testGetPost();
    await this.testGetFeed();
    await this.testLikePost();
    await this.testUnlikePost();
  }
}

class MessagingIntegrationTests {
  constructor(apiClient, wsClient, results) {
    this.api = apiClient;
    this.ws = wsClient;
    this.results = results;
  }

  async testSendMessage() {
    const testName = 'Send Message';
    const startTime = performance.now();
    
    try {
      const content = CONFIG.TEST_DATA.sampleMessages[0];
      const response = await this.api.sendMessage('test-user-id', content);
      
      if (response.success) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Send message failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testGetConversations() {
    const testName = 'Get Conversations';
    const startTime = performance.now();
    
    try {
      const response = await this.api.getConversations();
      
      if (response.success && Array.isArray(response.data)) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Get conversations failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testWebSocketConnection() {
    const testName = 'WebSocket Connection';
    const startTime = performance.now();
    
    try {
      if (!this.api.session || !this.api.session.token) {
        throw new Error('No valid session for WebSocket connection');
      }
      
      await this.ws.connect(this.api.session.token);
      
      if (this.ws.connected) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error('WebSocket connection failed');
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testRealTimeMessage() {
    const testName = 'Real-time Message';
    const startTime = performance.now();
    
    try {
      if (!this.ws.connected) {
        throw new Error('WebSocket not connected');
      }
      
      // Send a test message
      this.ws.sendMessage('test_message', { content: 'Integration test message' });
      
      // Wait for response
      const response = await this.ws.waitForMessage('message_received', 5000);
      
      if (response) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error('No response received for real-time message');
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async runAllTests() {
    console.log('Running Messaging Integration Tests...');
    await this.testSendMessage();
    await this.testGetConversations();
    await this.testWebSocketConnection();
    await this.testRealTimeMessage();
  }
}

class SearchIntegrationTests {
  constructor(apiClient, results) {
    this.api = apiClient;
    this.results = results;
  }

  async testSearchUsers() {
    const testName = 'Search Users';
    const startTime = performance.now();
    
    try {
      const response = await this.api.search('test');
      
      if (response.success && response.data && Array.isArray(response.data.users)) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Search users failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testSearchPosts() {
    const testName = 'Search Posts';
    const startTime = performance.now();
    
    try {
      const response = await this.api.search('test post');
      
      if (response.success && response.data && Array.isArray(response.data.posts)) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Search posts failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async testSearchHashtags() {
    const testName = 'Search Hashtags';
    const startTime = performance.now();
    
    try {
      const response = await this.api.search('#test');
      
      if (response.success && response.data && Array.isArray(response.data.hashtags)) {
        this.results.addTest(testName, 'passed', performance.now() - startTime);
      } else {
        throw new Error(`Search hashtags failed: ${response.status} - ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.results.addTest(testName, 'failed', performance.now() - startTime, error);
    }
  }

  async runAllTests() {
    console.log('Running Search Integration Tests...');
    await this.testSearchUsers();
    await this.testSearchPosts();
    await this.testSearchHashtags();
  }
}

// Main integration test runner
class IntegrationTestRunner {
  constructor(environment = 'local') {
    this.environment = environment;
    this.config = CONFIG.ENVIRONMENTS[environment];
    this.results = new TestResults();
    this.apiClient = new APIClient(this.config.baseURL);
    this.dbClient = new DatabaseClient(this.config.database);
    this.wsClient = new WebSocketClient(this.config.baseURL);
  }

  async setup() {
    console.log(`Setting up integration tests for environment: ${this.environment}`);
    
    // Connect to database
    await this.dbClient.connect();
    
    // Clean up test data
    await this.cleanupTestData();
  }

  async cleanup() {
    console.log('Cleaning up integration tests...');
    
    // Clean up test data
    await this.cleanupTestData();
    
    // Disconnect from database
    await this.dbClient.disconnect();
    
    // Disconnect WebSocket
    this.wsClient.disconnect();
  }

  async cleanupTestData() {
    // Clean up test users
    for (const user of CONFIG.TEST_DATA.sampleUsers) {
      try {
        await this.dbClient.deleteUser(user.email);
      } catch (error) {
        // Ignore errors during cleanup
      }
    }
  }

  async runAllTests() {
    console.log('Starting Integration Test Suite...');
    console.log(`Environment: ${this.environment}`);
    console.log(`Base URL: ${this.config.baseURL}`);
    console.log('==========================================');

    try {
      await this.setup();

      // Run test suites
      const authTests = new AuthIntegrationTests(this.apiClient, this.dbClient, this.results);
      await authTests.runAllTests();

      const postTests = new PostIntegrationTests(this.apiClient, this.dbClient, this.results);
      await postTests.runAllTests();

      const messagingTests = new MessagingIntegrationTests(this.apiClient, this.wsClient, this.results);
      await messagingTests.runAllTests();

      const searchTests = new SearchIntegrationTests(this.apiClient, this.results);
      await searchTests.runAllTests();

      // Generate report
      await this.generateReport();

    } catch (error) {
      console.error('Integration test suite failed:', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  async generateReport() {
    console.log('\n=== INTEGRATION TEST RESULTS ===');
    
    const summary = this.results.getSummary();
    
    console.log(`Total Tests: ${summary.total}`);
    console.log(`Passed: ${summary.passed}`);
    console.log(`Failed: ${summary.failed}`);
    console.log(`Skipped: ${summary.skipped}`);
    console.log(`Success Rate: ${summary.successRate.toFixed(2)}%`);
    console.log(`Duration: ${(summary.duration / 1000).toFixed(2)}s`);
    
    // Show failed tests
    if (summary.failed > 0) {
      console.log('\n=== FAILED TESTS ===');
      this.results.results.tests
        .filter(test => test.status === 'failed')
        .forEach(test => {
          console.log(`❌ ${test.name}: ${test.error}`);
        });
    }
    
    // Save results
    const filename = `integration-test-results-${this.environment}-${Date.now()}.json`;
    await this.results.saveResults(filename);
    console.log(`\nResults saved to: ${filename}`);
    
    // Exit with appropriate code
    if (summary.failed > 0) {
      process.exit(1);
    }
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  const environment = args[0] || 'local';
  
  console.log('ChitLaq M1 MVP Integration Test Suite');
  console.log('=====================================');
  
  const runner = new IntegrationTestRunner(environment);
  
  try {
    await runner.runAllTests();
    console.log('\n🎉 All integration tests passed!');
  } catch (error) {
    console.error('\n❌ Integration tests failed:', error.message);
    process.exit(1);
  }
}

// Export for use in other modules
module.exports = {
  IntegrationTestRunner,
  AuthIntegrationTests,
  PostIntegrationTests,
  MessagingIntegrationTests,
  SearchIntegrationTests,
  APIClient,
  DatabaseClient,
  WebSocketClient,
  TestResults,
  CONFIG
};

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}
