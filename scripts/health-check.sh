#!/bin/bash

# ChitLaq M1 MVP - Health Check Script
# Comprehensive health monitoring for all services
# Generated by PROMPT 1.4 - Monitoring & Observability Stack

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
LOG_FILE="/var/log/chitlaq/health-check.log"
TIMEOUT=30
RETRY_COUNT=3

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Health check results
declare -A HEALTH_STATUS
declare -A HEALTH_MESSAGES
OVERALL_STATUS="HEALTHY"

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}" | tee -a "$LOG_FILE"
}

success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}" | tee -a "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}[WARNING] $1${NC}" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[ERROR] $1${NC}" | tee -a "$LOG_FILE"
}

# Create log directory if it doesn't exist
mkdir -p "$(dirname "$LOG_FILE")"

# HTTP health check function
check_http_endpoint() {
    local service_name="$1"
    local url="$2"
    local expected_status="${3:-200}"
    local timeout="${4:-$TIMEOUT}"
    
    log "Checking $service_name at $url"
    
    local response
    local status_code
    
    if response=$(curl -s -w "%{http_code}" -o /dev/null --max-time "$timeout" "$url" 2>/dev/null); then
        status_code="$response"
        
        if [[ "$status_code" == "$expected_status" ]]; then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="HTTP $status_code"
            success "$service_name is healthy (HTTP $status_code)"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="HTTP $status_code (expected $expected_status)"
            error "$service_name returned HTTP $status_code (expected $expected_status)"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNHEALTHY"
        HEALTH_MESSAGES["$service_name"]="Connection failed"
        error "$service_name connection failed"
        return 1
    fi
}

# Database health check
check_database() {
    local service_name="PostgreSQL"
    log "Checking $service_name"
    
    if command -v psql >/dev/null 2>&1; then
        export PGPASSWORD="${DB_PASSWORD:-}"
        
        if psql -h "${DB_HOST:-localhost}" -p "${DB_PORT:-5432}" -U "${DB_USER:-chitlaq_app}" -d "${DB_NAME:-chitlaq_main}" -c "SELECT 1;" >/dev/null 2>&1; then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="Connection successful"
            success "$service_name is healthy"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="Connection failed"
            error "$service_name connection failed"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNKNOWN"
        HEALTH_MESSAGES["$service_name"]="psql not available"
        warning "$service_name check skipped (psql not available)"
        return 0
    fi
}

# Redis health check
check_redis() {
    local service_name="Redis"
    log "Checking $service_name"
    
    if command -v redis-cli >/dev/null 2>&1; then
        if redis-cli -h "${REDIS_HOST:-localhost}" -p "${REDIS_PORT:-6379}" ping >/dev/null 2>&1; then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="PONG response"
            success "$service_name is healthy"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="No PONG response"
            error "$service_name ping failed"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNKNOWN"
        HEALTH_MESSAGES["$service_name"]="redis-cli not available"
        warning "$service_name check skipped (redis-cli not available)"
        return 0
    fi
}

# Docker container health check
check_docker_container() {
    local container_name="$1"
    local service_name="$2"
    
    log "Checking Docker container: $container_name"
    
    if command -v docker >/dev/null 2>&1; then
        local container_status
        container_status=$(docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "unknown")
        
        case "$container_status" in
            "healthy")
                HEALTH_STATUS["$service_name"]="HEALTHY"
                HEALTH_MESSAGES["$service_name"]="Container healthy"
                success "$service_name container is healthy"
                return 0
                ;;
            "unhealthy")
                HEALTH_STATUS["$service_name"]="UNHEALTHY"
                HEALTH_MESSAGES["$service_name"]="Container unhealthy"
                error "$service_name container is unhealthy"
                return 1
                ;;
            "starting")
                HEALTH_STATUS["$service_name"]="STARTING"
                HEALTH_MESSAGES["$service_name"]="Container starting"
                warning "$service_name container is starting"
                return 0
                ;;
            *)
                # Fallback to container running status
                if docker ps --format "table {{.Names}}" | grep -q "^$container_name$"; then
                    HEALTH_STATUS["$service_name"]="HEALTHY"
                    HEALTH_MESSAGES["$service_name"]="Container running"
                    success "$service_name container is running"
                    return 0
                else
                    HEALTH_STATUS["$service_name"]="UNHEALTHY"
                    HEALTH_MESSAGES["$service_name"]="Container not running"
                    error "$service_name container is not running"
                    return 1
                fi
                ;;
        esac
    else
        HEALTH_STATUS["$service_name"]="UNKNOWN"
        HEALTH_MESSAGES["$service_name"]="Docker not available"
        warning "$service_name check skipped (Docker not available)"
        return 0
    fi
}

# Disk space check
check_disk_space() {
    local service_name="Disk Space"
    local threshold="${DISK_THRESHOLD:-80}"
    
    log "Checking $service_name (threshold: ${threshold}%)"
    
    local usage
    usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    
    if [[ "$usage" -lt "$threshold" ]]; then
        HEALTH_STATUS["$service_name"]="HEALTHY"
        HEALTH_MESSAGES["$service_name"]="${usage}% used"
        success "$service_name is healthy (${usage}% used)"
        return 0
    else
        HEALTH_STATUS["$service_name"]="UNHEALTHY"
        HEALTH_MESSAGES["$service_name"]="${usage}% used (threshold: ${threshold}%)"
        error "$service_name usage is ${usage}% (threshold: ${threshold}%)"
        return 1
    fi
}

# Memory usage check
check_memory() {
    local service_name="Memory"
    local threshold="${MEMORY_THRESHOLD:-90}"
    
    log "Checking $service_name (threshold: ${threshold}%)"
    
    local usage
    if command -v free >/dev/null 2>&1; then
        usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
        
        if [[ "$usage" -lt "$threshold" ]]; then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="${usage}% used"
            success "$service_name is healthy (${usage}% used)"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="${usage}% used (threshold: ${threshold}%)"
            error "$service_name usage is ${usage}% (threshold: ${threshold}%)"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNKNOWN"
        HEALTH_MESSAGES["$service_name"]="free command not available"
        warning "$service_name check skipped (free command not available)"
        return 0
    fi
}

# CPU load check
check_cpu_load() {
    local service_name="CPU Load"
    local threshold="${CPU_THRESHOLD:-4.0}"
    
    log "Checking $service_name (threshold: ${threshold})"
    
    local load
    if command -v uptime >/dev/null 2>&1; then
        load=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | xargs)
        
        if (( $(echo "$load < $threshold" | bc -l) )); then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="Load: $load"
            success "$service_name is healthy (load: $load)"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="Load: $load (threshold: $threshold)"
            error "$service_name load is $load (threshold: $threshold)"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNKNOWN"
        HEALTH_MESSAGES["$service_name"]="uptime command not available"
        warning "$service_name check skipped (uptime command not available)"
        return 0
    fi
}

# Network connectivity check
check_network() {
    local service_name="Network"
    local test_host="${NETWORK_TEST_HOST:-8.8.8.8}"
    
    log "Checking $service_name connectivity to $test_host"
    
    if ping -c 1 -W 5 "$test_host" >/dev/null 2>&1; then
        HEALTH_STATUS["$service_name"]="HEALTHY"
        HEALTH_MESSAGES["$service_name"]="Ping successful to $test_host"
        success "$service_name is healthy"
        return 0
    else
        HEALTH_STATUS["$service_name"]="UNHEALTHY"
        HEALTH_MESSAGES["$service_name"]="Ping failed to $test_host"
        error "$service_name ping failed to $test_host"
        return 1
    fi
}

# SSL certificate check
check_ssl_certificate() {
    local domain="$1"
    local service_name="SSL Certificate ($domain)"
    local days_threshold="${SSL_THRESHOLD:-30}"
    
    log "Checking $service_name (threshold: ${days_threshold} days)"
    
    local expiry_date
    local days_until_expiry
    
    if expiry_date=$(echo | openssl s_client -servername "$domain" -connect "$domain:443" 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2); then
        days_until_expiry=$(( ($(date -d "$expiry_date" +%s) - $(date +%s)) / 86400 ))
        
        if [[ "$days_until_expiry" -gt "$days_threshold" ]]; then
            HEALTH_STATUS["$service_name"]="HEALTHY"
            HEALTH_MESSAGES["$service_name"]="Expires in $days_until_expiry days"
            success "$service_name is healthy (expires in $days_until_expiry days)"
            return 0
        else
            HEALTH_STATUS["$service_name"]="UNHEALTHY"
            HEALTH_MESSAGES["$service_name"]="Expires in $days_until_expiry days (threshold: $days_threshold)"
            error "$service_name expires in $days_until_expiry days (threshold: $days_threshold)"
            return 1
        fi
    else
        HEALTH_STATUS["$service_name"]="UNHEALTHY"
        HEALTH_MESSAGES["$service_name"]="Certificate check failed"
        error "$service_name certificate check failed"
        return 1
    fi
}

# Generate health report
generate_health_report() {
    local report_file="${HEALTH_REPORT_FILE:-/tmp/chitlaq-health-report.json}"
    
    log "Generating health report: $report_file"
    
    cat > "$report_file" << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "overall_status": "$OVERALL_STATUS",
  "services": {
EOF

    local first=true
    for service in "${!HEALTH_STATUS[@]}"; do
        if [[ "$first" == true ]]; then
            first=false
        else
            echo "," >> "$report_file"
        fi
        
        cat >> "$report_file" << EOF
    "$service": {
      "status": "${HEALTH_STATUS[$service]}",
      "message": "${HEALTH_MESSAGES[$service]}"
    }
EOF
    done

    cat >> "$report_file" << EOF
  }
}
EOF

    success "Health report generated: $report_file"
}

# Main health check function
run_health_checks() {
    log "Starting ChitLaq health checks..."
    
    # Infrastructure checks
    check_disk_space
    check_memory
    check_cpu_load
    check_network
    
    # Database checks
    check_database
    check_redis
    
    # Application service checks
    check_http_endpoint "API Gateway" "http://localhost:3001/health" "200"
    check_http_endpoint "Web Application" "http://localhost:3000/api/health" "200"
    check_http_endpoint "Admin Panel" "http://localhost:3005/api/health" "200"
    check_http_endpoint "Realtime Service" "http://localhost:3002/health" "200"
    check_http_endpoint "Feed Service" "http://localhost:3003/health" "200"
    check_http_endpoint "Search Service" "http://localhost:3004/health" "200"
    
    # Monitoring stack checks
    check_http_endpoint "Prometheus" "http://localhost:9090/-/healthy" "200"
    check_http_endpoint "Grafana" "http://localhost:3000/api/health" "200"
    check_http_endpoint "Alertmanager" "http://localhost:9093/-/healthy" "200"
    check_http_endpoint "Loki" "http://localhost:3100/ready" "200"
    
    # Docker container checks
    check_docker_container "chitlaq-postgres" "PostgreSQL Container"
    check_docker_container "chitlaq-redis" "Redis Container"
    check_docker_container "chitlaq-nginx" "Nginx Container"
    
    # SSL certificate checks (if domain is configured)
    if [[ -n "${DOMAIN_NAME:-}" ]]; then
        check_ssl_certificate "$DOMAIN_NAME"
    fi
    
    # Determine overall status
    for status in "${HEALTH_STATUS[@]}"; do
        if [[ "$status" == "UNHEALTHY" ]]; then
            OVERALL_STATUS="UNHEALTHY"
            break
        elif [[ "$status" == "STARTING" && "$OVERALL_STATUS" == "HEALTHY" ]]; then
            OVERALL_STATUS="DEGRADED"
        fi
    done
    
    log "Health checks completed. Overall status: $OVERALL_STATUS"
    
    # Generate report
    generate_health_report
    
    # Exit with appropriate code
    case "$OVERALL_STATUS" in
        "HEALTHY")
            success "All health checks passed"
            exit 0
            ;;
        "DEGRADED")
            warning "Some services are starting or degraded"
            exit 1
            ;;
        "UNHEALTHY")
            error "Some services are unhealthy"
            exit 2
            ;;
        *)
            error "Unknown overall status: $OVERALL_STATUS"
            exit 3
            ;;
    esac
}

# Show usage information
show_usage() {
    cat <<EOF
ChitLaq Health Check Script

Usage: $0 [OPTIONS]

Options:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -q, --quiet         Suppress output (exit code only)
    -r, --report        Generate JSON report only
    -t, --timeout SEC   Set timeout for HTTP checks (default: 30)
    --disk-threshold %   Set disk usage threshold (default: 80)
    --memory-threshold % Set memory usage threshold (default: 90)
    --cpu-threshold NUM  Set CPU load threshold (default: 4.0)

Environment Variables:
    DB_HOST             Database host (default: localhost)
    DB_PORT             Database port (default: 5432)
    DB_USER             Database user (default: chitlaq_app)
    DB_NAME             Database name (default: chitlaq_main)
    DB_PASSWORD         Database password (required)
    REDIS_HOST          Redis host (default: localhost)
    REDIS_PORT          Redis port (default: 6379)
    DOMAIN_NAME         Domain name for SSL checks
    HEALTH_REPORT_FILE  Health report file path

Examples:
    # Basic health check
    $0
    
    # Health check with custom thresholds
    $0 --disk-threshold 85 --memory-threshold 95
    
    # Generate report only
    $0 --report

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--verbose)
            set -x
            shift
            ;;
        -q|--quiet)
            exec >/dev/null 2>&1
            shift
            ;;
        -r|--report)
            generate_health_report
            exit 0
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --disk-threshold)
            DISK_THRESHOLD="$2"
            shift 2
            ;;
        --memory-threshold)
            MEMORY_THRESHOLD="$2"
            shift 2
            ;;
        --cpu-threshold)
            CPU_THRESHOLD="$2"
            shift 2
            ;;
        *)
            error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Run health checks
run_health_checks
