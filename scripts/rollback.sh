#!/bin/bash

# ChitLaq M1 MVP - Rollback Script
# Generated by PROMPT 1.5 - CI/CD Pipeline & Automated Deployment
# Senior DevOps Engineer - 15+ years CI/CD and release management experience

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENVIRONMENT=""
ROLLBACK_VERSION=""
FORCE_ROLLBACK=false
DRY_RUN=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Rollback script for ChitLaq M1 MVP deployments

OPTIONS:
    --environment ENV     Target environment (staging|production) (required)
    --version VERSION     Specific version to rollback to (format: YYYYMMDD-HHMMSS)
    --force               Force rollback without confirmation
    --dry-run            Show what would be done without executing
    --help               Show this help message

EXAMPLES:
    $0 --environment staging
    $0 --environment production --version 20241201-143022
    $0 --environment production --force
    $0 --environment staging --dry-run

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            --version)
                ROLLBACK_VERSION="$2"
                shift 2
                ;;
            --force)
                FORCE_ROLLBACK=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$ENVIRONMENT" ]]; then
        log_error "Environment is required"
        usage
        exit 1
    fi

    if [[ "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "production" ]]; then
        log_error "Environment must be 'staging' or 'production'"
        exit 1
    fi
}

# Get available deployments
get_available_deployments() {
    local env="$1"
    local deployments_dir="/opt/chitlaq/$env/deployments"
    
    if [[ -d "$deployments_dir" ]]; then
        ls -t "$deployments_dir" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Get current deployment
get_current_deployment() {
    local env="$1"
    local current_link="/opt/chitlaq/$env/current"
    
    if [[ -L "$current_link" ]]; then
        basename "$(readlink "$current_link")"
    else
        echo ""
    fi
}

# Validate rollback version
validate_rollback_version() {
    local env="$1"
    local version="$2"
    local deployments_dir="/opt/chitlaq/$env/deployments"
    
    if [[ ! -d "$deployments_dir/$version" ]]; then
        log_error "Deployment version not found: $version"
        log_info "Available deployments:"
        get_available_deployments "$env" | head -10
        exit 1
    fi
    
    log_info "Rollback version validated: $version"
}

# Pre-rollback checks
pre_rollback_checks() {
    log_info "Running pre-rollback checks..."

    # Check if deployment directory exists
    if [[ ! -d "$PROJECT_ROOT" ]]; then
        log_error "Project root directory not found: $PROJECT_ROOT"
        exit 1
    fi

    # Check Docker availability
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose is not installed or not in PATH"
        exit 1
    fi

    # Check if Docker daemon is running
    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi

    # Check if environment is accessible
    local health_url=""
    if [[ "$ENVIRONMENT" == "staging" ]]; then
        health_url="https://staging.chitlaq.com/health"
    else
        health_url="https://chitlaq.com/health"
    fi

    if ! curl -f "$health_url" &> /dev/null; then
        log_warning "Current environment health check failed: $health_url"
        if ! $FORCE_ROLLBACK; then
            log_error "Cannot rollback unhealthy environment without --force"
            exit 1
        fi
    fi

    log_success "Pre-rollback checks passed"
}

# Get rollback information
get_rollback_info() {
    log_info "Gathering rollback information..."

    local current_deployment=$(get_current_deployment "$ENVIRONMENT")
    local available_deployments=($(get_available_deployments "$ENVIRONMENT"))
    
    if [[ -z "$current_deployment" ]]; then
        log_error "No current deployment found for environment: $ENVIRONMENT"
        exit 1
    fi

    log_info "Current deployment: $current_deployment"
    log_info "Available deployments: ${available_deployments[*]}"

    # Determine rollback version
    if [[ -z "$ROLLBACK_VERSION" ]]; then
        # Find the most recent deployment that's not the current one
        for deployment in "${available_deployments[@]}"; do
            if [[ "$deployment" != "$current_deployment" ]]; then
                ROLLBACK_VERSION="$deployment"
                break
            fi
        done
        
        if [[ -z "$ROLLBACK_VERSION" ]]; then
            log_error "No previous deployment found for rollback"
            exit 1
        fi
    fi

    validate_rollback_version "$ENVIRONMENT" "$ROLLBACK_VERSION"

    log_info "Rollback target: $ROLLBACK_VERSION"
    log_info "Rollback from: $current_deployment"
}

# Confirm rollback
confirm_rollback() {
    if $FORCE_ROLLBACK; then
        return 0
    fi

    log_warning "This will rollback $ENVIRONMENT environment from $current_deployment to $ROLLBACK_VERSION"
    log_warning "This action cannot be undone!"
    
    read -p "Are you sure you want to proceed? (yes/no): " -r
    if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
        log_info "Rollback cancelled by user"
        exit 0
    fi
}

# Create rollback backup
create_rollback_backup() {
    log_info "Creating rollback backup..."

    local backup_file="$PROJECT_ROOT/backups/pre-rollback-$(date +%Y%m%d-%H%M%S).sql"
    
    # Create database backup
    if docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres pg_isready -U postgres &> /dev/null; then
        docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres pg_dump -U postgres chitlaq > "$backup_file"
        
        # Encrypt backup
        if command -v gpg &> /dev/null; then
            gpg --symmetric --cipher-algo AES256 --output "$backup_file.gpg" "$backup_file"
            rm "$backup_file"
            log_info "Rollback backup created: $(basename "$backup_file.gpg")"
        else
            log_info "Rollback backup created: $(basename "$backup_file")"
        fi
    else
        log_warning "Database not accessible, skipping backup"
    fi
}

# Stop current services
stop_current_services() {
    log_info "Stopping current services..."

    if $DRY_RUN; then
        log_info "[DRY RUN] Would stop current services"
        return 0
    fi

    # Stop current deployment
    cd "$PROJECT_ROOT"
    docker-compose -f docker-compose.yml down

    log_success "Current services stopped"
}

# Switch to rollback version
switch_to_rollback_version() {
    log_info "Switching to rollback version: $ROLLBACK_VERSION"

    if $DRY_RUN; then
        log_info "[DRY RUN] Would switch to version: $ROLLBACK_VERSION"
        return 0
    fi

    local deployments_dir="/opt/chitlaq/$ENVIRONMENT/deployments"
    local current_link="/opt/chitlaq/$ENVIRONMENT/current"
    local rollback_path="$deployments_dir/$ROLLBACK_VERSION"

    # Update symlink to rollback version
    ln -sfn "$rollback_path" "$current_link"
    
    # Change to rollback directory
    cd "$rollback_path"

    log_success "Switched to rollback version: $ROLLBACK_VERSION"
}

# Start rollback services
start_rollback_services() {
    log_info "Starting rollback services..."

    if $DRY_RUN; then
        log_info "[DRY RUN] Would start rollback services"
        return 0
    fi

    # Start services
    docker-compose -f docker-compose.yml up -d

    # Wait for services to be ready
    log_info "Waiting for services to be ready..."
    local max_attempts=60
    local attempt=1

    while [[ $attempt -le $max_attempts ]]; do
        local health_url=""
        if [[ "$ENVIRONMENT" == "staging" ]]; then
            health_url="http://localhost:3001/health"
        else
            health_url="https://chitlaq.com/health"
        fi

        if curl -f "$health_url" &> /dev/null; then
            log_success "Rollback services are ready"
            break
        fi

        if [[ $attempt -eq $max_attempts ]]; then
            log_error "Rollback services failed to start within timeout"
            docker-compose -f docker-compose.yml logs
            exit 1
        fi

        log_info "Waiting for rollback services... (attempt $attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done
}

# Verify rollback
verify_rollback() {
    log_info "Verifying rollback..."

    if $DRY_RUN; then
        log_info "[DRY RUN] Would verify rollback"
        return 0
    fi

    local health_url=""
    if [[ "$ENVIRONMENT" == "staging" ]]; then
        health_url="https://staging.chitlaq.com/health"
    else
        health_url="https://chitlaq.com/health"
    fi

    # Run health checks
    log_info "Running health checks..."
    if [[ -f "$PROJECT_ROOT/scripts/health-check.sh" ]]; then
        "$PROJECT_ROOT/scripts/health-check.sh" --env="$ENVIRONMENT"
    fi

    # Test critical endpoints
    log_info "Testing critical endpoints..."
    local endpoints=()
    if [[ "$ENVIRONMENT" == "staging" ]]; then
        endpoints=(
            "https://staging.chitlaq.com/api/health"
            "https://staging.chitlaq.com/api/feed"
            "https://staging.chitlaq.com/api/search?q=test"
        )
    else
        endpoints=(
            "https://chitlaq.com/api/health"
            "https://chitlaq.com/api/feed"
            "https://chitlaq.com/api/search?q=test"
        )
    fi

    for endpoint in "${endpoints[@]}"; do
        if curl -f "$endpoint" &> /dev/null; then
            log_success "Endpoint verified: $endpoint"
        else
            log_warning "Endpoint failed: $endpoint"
        fi
    done

    # Check database connectivity
    log_info "Checking database connectivity..."
    if docker-compose -f docker-compose.yml exec -T postgres pg_isready -U postgres &> /dev/null; then
        log_success "Database connectivity verified"
    else
        log_error "Database connectivity failed"
        exit 1
    fi

    log_success "Rollback verification completed"
}

# Post-rollback tasks
post_rollback_tasks() {
    log_info "Running post-rollback tasks..."

    if $DRY_RUN; then
        log_info "[DRY RUN] Would run post-rollback tasks"
        return 0
    fi

    # Update monitoring
    log_info "Updating monitoring configuration..."
    # This would typically involve updating Prometheus targets, Grafana dashboards, etc.

    # Clear caches
    log_info "Clearing caches..."
    # This would typically involve clearing application caches, CDN caches, etc.

    # Update deployment status
    log_info "Updating deployment status..."
    # This would typically involve updating a deployment tracking system

    # Send notifications
    log_info "Sending rollback notifications..."
    # This would typically involve sending notifications to relevant teams

    log_success "Post-rollback tasks completed"
}

# Main rollback function
main() {
    log_info "Starting rollback process..."
    log_info "Environment: $ENVIRONMENT"
    log_info "Rollback Version: $ROLLBACK_VERSION"
    log_info "Force Rollback: $FORCE_ROLLBACK"
    log_info "Dry Run: $DRY_RUN"

    # Change to project root directory
    cd "$PROJECT_ROOT"

    # Run rollback steps
    pre_rollback_checks
    get_rollback_info
    confirm_rollback
    create_rollback_backup
    stop_current_services
    switch_to_rollback_version
    start_rollback_services
    verify_rollback
    post_rollback_tasks

    log_success "Rollback completed successfully!"
    log_info "Environment: $ENVIRONMENT"
    log_info "Rollback Version: $ROLLBACK_VERSION"
    log_info "Services are running and ready for traffic"
}

# Error handling
trap 'log_error "Rollback failed at line $LINENO"; exit 1' ERR

# Parse arguments and run main function
parse_args "$@"
main
