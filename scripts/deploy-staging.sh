#!/bin/bash

# ChitLaq M1 MVP - Staging Deployment Script
# Generated by PROMPT 1.5 - CI/CD Pipeline & Automated Deployment
# Senior DevOps Engineer - 15+ years CI/CD and release management experience

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENVIRONMENT="staging"
DEPLOYMENT_ID=""
BLUE_GREEN_MODE=false
SKIP_TESTS=false
FORCE_DEPLOY=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Staging deployment script for ChitLaq M1 MVP

OPTIONS:
    --deployment-id ID    Deployment ID (required)
    --blue-green          Enable blue-green deployment
    --skip-tests          Skip running tests
    --force               Force deployment (skip checks)
    --help                Show this help message

EXAMPLES:
    $0 --deployment-id 20241201-143022
    $0 --deployment-id 20241201-143022 --blue-green
    $0 --deployment-id 20241201-143022 --skip-tests --force

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --deployment-id)
                DEPLOYMENT_ID="$2"
                shift 2
                ;;
            --blue-green)
                BLUE_GREEN_MODE=true
                shift
                ;;
            --skip-tests)
                SKIP_TESTS=true
                shift
                ;;
            --force)
                FORCE_DEPLOY=true
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$DEPLOYMENT_ID" ]]; then
        log_error "Deployment ID is required"
        usage
        exit 1
    fi
}

# Pre-deployment checks
pre_deployment_checks() {
    log_info "Running pre-deployment checks..."

    # Check if deployment directory exists
    if [[ ! -d "$PROJECT_ROOT" ]]; then
        log_error "Project root directory not found: $PROJECT_ROOT"
        exit 1
    fi

    # Check if required files exist
    local required_files=(
        "docker-compose.yml"
        ".env"
        "package.json"
    )

    for file in "${required_files[@]}"; do
        if [[ ! -f "$PROJECT_ROOT/$file" ]]; then
            log_error "Required file not found: $file"
            exit 1
        fi
    done

    # Check Docker availability
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose is not installed or not in PATH"
        exit 1
    fi

    # Check if Docker daemon is running
    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi

    # Check disk space (minimum 5GB free)
    local available_space=$(df "$PROJECT_ROOT" | awk 'NR==2 {print $4}')
    local required_space=5242880 # 5GB in KB
    
    if [[ $available_space -lt $required_space ]]; then
        log_error "Insufficient disk space. Required: 5GB, Available: $((available_space / 1024 / 1024))GB"
        exit 1
    fi

    # Check memory (minimum 4GB available)
    local available_memory=$(free -m | awk 'NR==2{printf "%.0f", $7}')
    local required_memory=4096 # 4GB in MB
    
    if [[ $available_memory -lt $required_memory ]]; then
        log_warning "Low memory available: ${available_memory}MB (recommended: ${required_memory}MB)"
    fi

    log_success "Pre-deployment checks passed"
}

# Environment setup
setup_environment() {
    log_info "Setting up environment..."

    # Load environment variables
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        set -a
        source "$PROJECT_ROOT/.env"
        set +a
        log_info "Environment variables loaded from .env"
    else
        log_error "Environment file not found: .env"
        exit 1
    fi

    # Set deployment-specific environment variables
    export DEPLOYMENT_ID="$DEPLOYMENT_ID"
    export ENVIRONMENT="$ENVIRONMENT"
    export COMPOSE_PROJECT_NAME="chitlaq-staging"

    # Create necessary directories
    mkdir -p "$PROJECT_ROOT/logs"
    mkdir -p "$PROJECT_ROOT/backups"
    mkdir -p "$PROJECT_ROOT/data"

    log_success "Environment setup completed"
}

# Database migration
run_database_migration() {
    log_info "Running database migration..."

    # Check if database is accessible
    if ! docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres pg_isready -U postgres &> /dev/null; then
        log_error "Database is not accessible"
        exit 1
    fi

    # Create backup before migration
    log_info "Creating pre-migration backup..."
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres pg_dump -U postgres chitlaq > "$PROJECT_ROOT/backups/pre-migration-$(date +%Y%m%d-%H%M%S).sql"

    # Run migrations
    if [[ -d "$PROJECT_ROOT/migrations" ]]; then
        log_info "Running database migrations..."
        for migration in "$PROJECT_ROOT/migrations"/*.sql; do
            if [[ -f "$migration" ]]; then
                log_info "Applying migration: $(basename "$migration")"
                docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres psql -U postgres -d chitlaq -f "/migrations/$(basename "$migration")"
            fi
        done
    else
        log_warning "No migrations directory found"
    fi

    log_success "Database migration completed"
}

# Build and pull images
build_images() {
    log_info "Building and pulling Docker images..."

    # Pull latest images
    log_info "Pulling latest images..."
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" pull

    # Build custom images
    log_info "Building custom images..."
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" build --no-cache

    # Tag images with deployment ID
    log_info "Tagging images with deployment ID: $DEPLOYMENT_ID"
    docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | grep chitlaq | while read -r repo tag id; do
        if [[ "$tag" != "latest" ]]; then
            docker tag "$id" "$repo:$DEPLOYMENT_ID"
        fi
    done

    log_success "Image build and pull completed"
}

# Blue-green deployment
blue_green_deployment() {
    log_info "Starting blue-green deployment..."

    # Determine current and new environments
    local current_env=""
    local new_env=""

    if docker-compose -f "$PROJECT_ROOT/docker-compose.yml" ps | grep -q "chitlaq-staging-blue"; then
        current_env="blue"
        new_env="green"
    else
        current_env="green"
        new_env="blue"
    fi

    log_info "Current environment: $current_env, New environment: $new_env"

    # Start new environment
    log_info "Starting new environment ($new_env)..."
    export COMPOSE_PROJECT_NAME="chitlaq-staging-$new_env"
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" up -d

    # Wait for new environment to be ready
    log_info "Waiting for new environment to be ready..."
    local max_attempts=30
    local attempt=1

    while [[ $attempt -le $max_attempts ]]; do
        if curl -f "http://localhost:3001/health" &> /dev/null; then
            log_success "New environment is ready"
            break
        fi

        if [[ $attempt -eq $max_attempts ]]; then
            log_error "New environment failed to start within timeout"
            docker-compose -f "$PROJECT_ROOT/docker-compose.yml" logs
            exit 1
        fi

        log_info "Waiting for new environment... (attempt $attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done

    # Run health checks on new environment
    if ! $SKIP_TESTS; then
        log_info "Running health checks on new environment..."
        "$PROJECT_ROOT/scripts/health-check.sh" --env=staging --comprehensive
    fi

    # Switch traffic to new environment
    log_info "Switching traffic to new environment..."
    # Update nginx configuration to point to new environment
    # This would typically involve updating nginx config and reloading

    # Stop old environment
    log_info "Stopping old environment ($current_env)..."
    export COMPOSE_PROJECT_NAME="chitlaq-staging-$current_env"
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" down

    log_success "Blue-green deployment completed"
}

# Standard deployment
standard_deployment() {
    log_info "Starting standard deployment..."

    # Stop existing services
    log_info "Stopping existing services..."
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" down

    # Start services
    log_info "Starting services..."
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" up -d

    # Wait for services to be ready
    log_info "Waiting for services to be ready..."
    local max_attempts=30
    local attempt=1

    while [[ $attempt -le $max_attempts ]]; do
        if curl -f "http://localhost:3001/health" &> /dev/null; then
            log_success "Services are ready"
            break
        fi

        if [[ $attempt -eq $max_attempts ]]; then
            log_error "Services failed to start within timeout"
            docker-compose -f "$PROJECT_ROOT/docker-compose.yml" logs
            exit 1
        fi

        log_info "Waiting for services... (attempt $attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done

    log_success "Standard deployment completed"
}

# Post-deployment tasks
post_deployment_tasks() {
    log_info "Running post-deployment tasks..."

    # Run health checks
    if ! $SKIP_TESTS; then
        log_info "Running health checks..."
        "$PROJECT_ROOT/scripts/health-check.sh" --env=staging
    fi

    # Warm up caches
    log_info "Warming up caches..."
    curl -f "http://localhost:3001/api/feed" &> /dev/null || true
    curl -f "http://localhost:3001/api/search?q=test" &> /dev/null || true

    # Update monitoring
    log_info "Updating monitoring configuration..."
    # This would typically involve updating Prometheus targets, Grafana dashboards, etc.

    # Clean up old images
    log_info "Cleaning up old images..."
    docker image prune -f

    log_success "Post-deployment tasks completed"
}

# Rollback function
rollback() {
    log_warning "Rolling back deployment..."

    # Stop current services
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" down

    # Restore from backup if available
    local latest_backup=$(ls -t "$PROJECT_ROOT/backups"/*.sql 2>/dev/null | head -n 1)
    if [[ -n "$latest_backup" ]]; then
        log_info "Restoring database from backup: $(basename "$latest_backup")"
        docker-compose -f "$PROJECT_ROOT/docker-compose.yml" up -d postgres
        sleep 10
        docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres psql -U postgres -d chitlaq -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
        docker-compose -f "$PROJECT_ROOT/docker-compose.yml" exec -T postgres psql -U postgres -d chitlaq < "$latest_backup"
    fi

    # Start previous version
    docker-compose -f "$PROJECT_ROOT/docker-compose.yml" up -d

    log_success "Rollback completed"
}

# Main deployment function
main() {
    log_info "Starting staging deployment..."
    log_info "Deployment ID: $DEPLOYMENT_ID"
    log_info "Environment: $ENVIRONMENT"
    log_info "Blue-Green Mode: $BLUE_GREEN_MODE"
    log_info "Skip Tests: $SKIP_TESTS"
    log_info "Force Deploy: $FORCE_DEPLOY"

    # Change to project root directory
    cd "$PROJECT_ROOT"

    # Run deployment steps
    if ! $FORCE_DEPLOY; then
        pre_deployment_checks
    fi

    setup_environment
    run_database_migration
    build_images

    if $BLUE_GREEN_MODE; then
        blue_green_deployment
    else
        standard_deployment
    fi

    post_deployment_tasks

    log_success "Staging deployment completed successfully!"
    log_info "Deployment ID: $DEPLOYMENT_ID"
    log_info "Environment: $ENVIRONMENT"
    log_info "Services are running and ready for testing"
}

# Error handling
trap 'log_error "Deployment failed at line $LINENO"; rollback; exit 1' ERR

# Parse arguments and run main function
parse_args "$@"
main
