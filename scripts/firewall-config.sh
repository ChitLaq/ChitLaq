#!/bin/bash

# ChitLaq M1 MVP - Firewall Configuration Script
# Production-grade iptables rules with DDoS protection
# Generated by PROMPT 1.2 - Security Configuration Setup

set -e  # Exit on any error
set -u  # Exit on undefined variables
set -o pipefail  # Exit on pipe failures

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENV_FILE="${PROJECT_ROOT}/.env"

# Default values
ACTION=${1:-apply}
SAVE_RULES=${2:-true}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

info() {
    echo -e "${PURPLE}[INFO]${NC} $1"
}

# Print firewall banner
print_banner() {
    echo -e "${PURPLE}"
    echo "  _____ _                        _ _ "
    echo " |  ___(_)_ __ _____      ____ _| | |"
    echo " | |_  | | '__/ _ \ \ /\ / / _\` | | |"
    echo " |  _| | | | |  __/\ V  V / (_| | | |"
    echo " |_|   |_|_|  \___| \_/\_/ \__,_|_|_|"
    echo ""
    echo "ChitLaq Firewall Configuration"
    echo "Production Security Rules"
    echo "========================="
    echo -e "${NC}"
}

# Load environment configuration
load_environment() {
    log "Loading environment configuration..."
    
    if [ -f "$ENV_FILE" ]; then
        source "$ENV_FILE"
    else
        warning "Environment file not found, using defaults"
    fi
    
    # Set firewall configuration
    SSH_PORT=${SSH_PORT:-22}
    HTTP_PORT=${HTTP_PORT:-80}
    HTTPS_PORT=${HTTPS_PORT:-443}
    
    # Rate limiting configuration
    HTTP_RATE_LIMIT=${HTTP_RATE_LIMIT:-25}
    HTTPS_RATE_LIMIT=${HTTPS_RATE_LIMIT:-25}
    SSH_RATE_LIMIT=${SSH_RATE_LIMIT:-5}
    
    # DDoS protection settings
    DDOS_PROTECTION=${DDOS_PROTECTION:-true}
    SYN_FLOOD_PROTECTION=${SYN_FLOOD_PROTECTION:-true}
    PING_FLOOD_PROTECTION=${PING_FLOOD_PROTECTION:-true}
    
    # Allowed management IPs (add your office/home IPs here)
    ADMIN_IPS=${ADMIN_IPS:-""}
    
    success "Environment configuration loaded"
}

# Check prerequisites
check_prerequisites() {
    log "Checking firewall prerequisites..."
    
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        error "This script must be run as root (use sudo)"
        exit 1
    fi
    
    # Check if iptables is available
    if ! command -v iptables >/dev/null 2>&1; then
        error "iptables is not installed"
        exit 1
    fi
    
    # Check if iptables-persistent is available (for saving rules)
    if [ "$SAVE_RULES" = "true" ] && ! command -v iptables-save >/dev/null 2>&1; then
        log "Installing iptables-persistent for rule persistence..."
        
        if [ -f /etc/debian_version ]; then
            apt-get update
            DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent
        elif [ -f /etc/redhat-release ]; then
            if command -v dnf >/dev/null 2>&1; then
                dnf install -y iptables-services
            else
                yum install -y iptables-services
            fi
        fi
    fi
    
    success "Prerequisites check passed"
}

# Backup existing rules
backup_existing_rules() {
    log "Backing up existing iptables rules..."
    
    local backup_dir="${PROJECT_ROOT}/firewall-backups"
    mkdir -p "$backup_dir"
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$backup_dir/iptables-backup-$timestamp.rules"
    
    iptables-save > "$backup_file"
    success "Existing rules backed up to: $backup_file"
}

# Clear existing rules
clear_existing_rules() {
    log "Clearing existing iptables rules..."
    
    # Set default policies to ACCEPT before flushing
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    
    # Flush all rules
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t nat -X
    iptables -t mangle -F
    iptables -t mangle -X
    
    success "Existing rules cleared"
}

# Set default policies
set_default_policies() {
    log "Setting default firewall policies..."
    
    # Set restrictive default policies
    iptables -P INPUT DROP
    iptables -P FORWARD DROP
    iptables -P OUTPUT ACCEPT
    
    success "Default policies configured (DROP input/forward, ACCEPT output)"
}

# Configure loopback interface
configure_loopback() {
    log "Configuring loopback interface rules..."
    
    # Allow all loopback traffic
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A OUTPUT -o lo -j ACCEPT
    
    # Deny loopback traffic from non-loopback interfaces
    iptables -A INPUT -s 127.0.0.0/8 ! -i lo -j DROP
    
    success "Loopback interface configured"
}

# Configure connection tracking
configure_connection_tracking() {
    log "Configuring connection tracking rules..."
    
    # Allow established and related connections
    iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    
    # Drop invalid packets
    iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
    
    success "Connection tracking configured"
}

# Configure DDoS protection
configure_ddos_protection() {
    if [ "$DDOS_PROTECTION" != "true" ]; then
        log "DDoS protection disabled, skipping..."
        return
    fi
    
    log "Configuring DDoS protection rules..."
    
    # Limit new TCP connections per second per source IP
    iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 -j REJECT --reject-with tcp-reset
    iptables -A INPUT -p tcp --dport 443 -m connlimit --connlimit-above 20 -j REJECT --reject-with tcp-reset
    
    # Limit TCP connection rate
    iptables -A INPUT -p tcp --dport 80 -m recent --set --name HTTP
    iptables -A INPUT -p tcp --dport 80 -m recent --update --seconds 60 --hitcount 20 --name HTTP -j DROP
    
    iptables -A INPUT -p tcp --dport 443 -m recent --set --name HTTPS
    iptables -A INPUT -p tcp --dport 443 -m recent --update --seconds 60 --hitcount 20 --name HTTPS -j DROP
    
    # Protection against port scans
    iptables -A INPUT -m recent --set --name portscan --rsource
    iptables -A INPUT -m recent --update --seconds 60 --hitcount 10 --name portscan --rsource -j DROP
    
    success "DDoS protection configured"
}

# Configure SYN flood protection
configure_syn_flood_protection() {
    if [ "$SYN_FLOOD_PROTECTION" != "true" ]; then
        log "SYN flood protection disabled, skipping..."
        return
    fi
    
    log "Configuring SYN flood protection..."
    
    # Limit SYN packets
    iptables -A INPUT -p tcp --syn -m limit --limit 2/s --limit-burst 6 -j ACCEPT
    iptables -A INPUT -p tcp --syn -j DROP
    
    # Enable SYN cookies via sysctl
    echo 1 > /proc/sys/net/ipv4/tcp_syncookies
    
    success "SYN flood protection configured"
}

# Configure ping flood protection
configure_ping_protection() {
    if [ "$PING_FLOOD_PROTECTION" != "true" ]; then
        log "Ping flood protection disabled, skipping..."
        return
    fi
    
    log "Configuring ping flood protection..."
    
    # Limit ping requests
    iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 3 -j ACCEPT
    iptables -A INPUT -p icmp --icmp-type echo-request -j DROP
    
    # Allow other necessary ICMP types
    iptables -A INPUT -p icmp --icmp-type destination-unreachable -j ACCEPT
    iptables -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT
    iptables -A INPUT -p icmp --icmp-type parameter-problem -j ACCEPT
    
    success "Ping flood protection configured"
}

# Configure SSH access
configure_ssh_access() {
    log "Configuring SSH access rules..."
    
    # Rate limit SSH connections
    iptables -A INPUT -p tcp --dport "$SSH_PORT" -m recent --set --name SSH
    iptables -A INPUT -p tcp --dport "$SSH_PORT" -m recent --update --seconds 300 --hitcount "$SSH_RATE_LIMIT" --name SSH -j DROP
    
    # Allow SSH from admin IPs
    if [ -n "$ADMIN_IPS" ]; then
        IFS=',' read -ra IP_ARRAY <<< "$ADMIN_IPS"
        for ip in "${IP_ARRAY[@]}"; do
            ip=$(echo "$ip" | xargs)  # Trim whitespace
            if [ -n "$ip" ]; then
                iptables -A INPUT -p tcp --dport "$SSH_PORT" -s "$ip" -j ACCEPT
                log "SSH access allowed from: $ip"
            fi
        done
    else
        # Allow SSH from anywhere (with rate limiting)
        iptables -A INPUT -p tcp --dport "$SSH_PORT" -j ACCEPT
        warning "SSH access allowed from anywhere (consider restricting to specific IPs)"
    fi
    
    success "SSH access configured"
}

# Configure HTTP/HTTPS access
configure_web_access() {
    log "Configuring HTTP/HTTPS access rules..."
    
    # Allow HTTP (port 80) with rate limiting
    iptables -A INPUT -p tcp --dport "$HTTP_PORT" -m limit --limit "${HTTP_RATE_LIMIT}/minute" --limit-burst 10 -j ACCEPT
    
    # Allow HTTPS (port 443) with rate limiting
    iptables -A INPUT -p tcp --dport "$HTTPS_PORT" -m limit --limit "${HTTPS_RATE_LIMIT}/minute" --limit-burst 10 -j ACCEPT
    
    success "HTTP/HTTPS access configured"
}

# Configure Docker networking
configure_docker_networking() {
    log "Configuring Docker networking rules..."
    
    # Allow Docker internal networking
    iptables -I INPUT -i docker0 -j ACCEPT
    iptables -I FORWARD -i docker0 -j ACCEPT
    iptables -I FORWARD -o docker0 -j ACCEPT
    
    # Allow Docker Compose network
    if docker network ls | grep -q chitlaq; then
        local docker_subnet
        docker_subnet=$(docker network inspect chitlaq_chitlaq_network --format='{{range .IPAM.Config}}{{.Subnet}}{{end}}' 2>/dev/null || echo "172.20.0.0/16")
        iptables -I INPUT -s "$docker_subnet" -j ACCEPT
        iptables -I FORWARD -s "$docker_subnet" -j ACCEPT
        iptables -I FORWARD -d "$docker_subnet" -j ACCEPT
        log "Docker network rules applied for subnet: $docker_subnet"
    fi
    
    success "Docker networking configured"
}

# Configure monitoring access
configure_monitoring_access() {
    log "Configuring monitoring service access..."
    
    # Grafana (port 3000) - restricted access
    if [ -n "$ADMIN_IPS" ]; then
        IFS=',' read -ra IP_ARRAY <<< "$ADMIN_IPS"
        for ip in "${IP_ARRAY[@]}"; do
            ip=$(echo "$ip" | xargs)
            if [ -n "$ip" ]; then
                iptables -A INPUT -p tcp --dport 3000 -s "$ip" -j ACCEPT
            fi
        done
    else
        # Allow from localhost only
        iptables -A INPUT -p tcp --dport 3000 -s 127.0.0.1 -j ACCEPT
    fi
    
    # Prometheus (port 9090) - localhost only
    iptables -A INPUT -p tcp --dport 9090 -s 127.0.0.1 -j ACCEPT
    
    # Supabase Studio (port 3010) - restricted access
    if [ -n "$ADMIN_IPS" ]; then
        IFS=',' read -ra IP_ARRAY <<< "$ADMIN_IPS"
        for ip in "${IP_ARRAY[@]}"; do
            ip=$(echo "$ip" | xargs)
            if [ -n "$ip" ]; then
                iptables -A INPUT -p tcp --dport 3010 -s "$ip" -j ACCEPT
            fi
        done
    else
        iptables -A INPUT -p tcp --dport 3010 -s 127.0.0.1 -j ACCEPT
    fi
    
    success "Monitoring access configured"
}

# Configure logging rules
configure_logging() {
    log "Configuring firewall logging rules..."
    
    # Log dropped packets (limited to prevent log spam)
    iptables -A INPUT -m limit --limit 5/min --limit-burst 10 -j LOG --log-prefix "IPTables-Dropped: " --log-level 4
    
    # Log new connections to web ports
    iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate NEW -m limit --limit 10/min -j LOG --log-prefix "HTTP-Connection: "
    iptables -A INPUT -p tcp --dport 443 -m conntrack --ctstate NEW -m limit --limit 10/min -j LOG --log-prefix "HTTPS-Connection: "
    
    success "Firewall logging configured"
}

# Configure fail2ban integration
configure_fail2ban() {
    log "Configuring fail2ban integration..."
    
    # Create fail2ban chain for integration
    iptables -N fail2ban-ssh 2>/dev/null || true
    iptables -I INPUT -p tcp --dport "$SSH_PORT" -j fail2ban-ssh
    iptables -A fail2ban-ssh -j RETURN
    
    # Create fail2ban chain for HTTP
    iptables -N fail2ban-nginx-http-auth 2>/dev/null || true
    iptables -I INPUT -p tcp --dport 80 -j fail2ban-nginx-http-auth
    iptables -A fail2ban-nginx-http-auth -j RETURN
    
    success "Fail2ban integration configured"
}

# Apply firewall rules
apply_firewall_rules() {
    log "Applying comprehensive firewall rules..."
    
    # Backup existing rules
    backup_existing_rules
    
    # Clear existing rules
    clear_existing_rules
    
    # Set default policies
    set_default_policies
    
    # Configure basic rules
    configure_loopback
    configure_connection_tracking
    
    # Configure protection rules
    configure_ddos_protection
    configure_syn_flood_protection
    configure_ping_protection
    
    # Configure service access
    configure_ssh_access
    configure_web_access
    configure_docker_networking
    configure_monitoring_access
    
    # Configure logging and fail2ban
    configure_logging
    configure_fail2ban
    
    success "Firewall rules applied successfully"
}

# Save firewall rules
save_firewall_rules() {
    if [ "$SAVE_RULES" != "true" ]; then
        log "Rule saving disabled, skipping..."
        return
    fi
    
    log "Saving firewall rules for persistence..."
    
    if [ -f /etc/debian_version ]; then
        # Debian/Ubuntu
        iptables-save > /etc/iptables/rules.v4
        success "Rules saved to /etc/iptables/rules.v4"
    elif [ -f /etc/redhat-release ]; then
        # RHEL/CentOS/Fedora
        iptables-save > /etc/sysconfig/iptables
        systemctl enable iptables
        success "Rules saved to /etc/sysconfig/iptables"
    else
        # Generic save
        iptables-save > "${PROJECT_ROOT}/iptables.rules"
        warning "Rules saved to ${PROJECT_ROOT}/iptables.rules"
        warning "Please configure your system to load these rules on boot"
    fi
}

# Show current firewall status
show_firewall_status() {
    echo ""
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}üõ°Ô∏è  ChitLaq Firewall Status${NC}"
    echo -e "${GREEN}================================================${NC}"
    echo ""
    
    # Show rule counts
    local input_rules=$(iptables -L INPUT --line-numbers | wc -l)
    local forward_rules=$(iptables -L FORWARD --line-numbers | wc -l)
    local output_rules=$(iptables -L OUTPUT --line-numbers | wc -l)
    
    echo -e "${BLUE}üìä Rule Statistics:${NC}"
    echo "  üì• INPUT rules: $((input_rules - 3))"
    echo "  ‚û°Ô∏è  FORWARD rules: $((forward_rules - 3))"
    echo "  üì§ OUTPUT rules: $((output_rules - 3))"
    echo ""
    
    # Show open ports
    echo -e "${BLUE}üîì Open Ports:${NC}"
    echo "  üåê HTTP: $HTTP_PORT"
    echo "  üîí HTTPS: $HTTPS_PORT"
    echo "  üîë SSH: $SSH_PORT"
    echo ""
    
    # Show protection status
    echo -e "${BLUE}üõ°Ô∏è  Protection Features:${NC}"
    echo "  üö´ DDoS Protection: $([ "$DDOS_PROTECTION" = "true" ] && echo "‚úÖ Enabled" || echo "‚ùå Disabled")"
    echo "  üö´ SYN Flood Protection: $([ "$SYN_FLOOD_PROTECTION" = "true" ] && echo "‚úÖ Enabled" || echo "‚ùå Disabled")"
    echo "  üö´ Ping Flood Protection: $([ "$PING_FLOOD_PROTECTION" = "true" ] && echo "‚úÖ Enabled" || echo "‚ùå Disabled")"
    echo ""
    
    # Show rate limits
    echo -e "${BLUE}‚è±Ô∏è  Rate Limits:${NC}"
    echo "  üåê HTTP: $HTTP_RATE_LIMIT/minute"
    echo "  üîí HTTPS: $HTTPS_RATE_LIMIT/minute"
    echo "  üîë SSH: $SSH_RATE_LIMIT/5min"
    echo ""
    
    # Show admin access
    if [ -n "$ADMIN_IPS" ]; then
        echo -e "${BLUE}üë• Admin Access IPs:${NC}"
        IFS=',' read -ra IP_ARRAY <<< "$ADMIN_IPS"
        for ip in "${IP_ARRAY[@]}"; do
            ip=$(echo "$ip" | xargs)
            if [ -n "$ip" ]; then
                echo "  üè† $ip"
            fi
        done
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Admin access: Not restricted by IP${NC}"
    fi
    echo ""
    
    echo -e "${GREEN}‚úÖ Firewall Status: ACTIVE${NC}"
    echo ""
}

# List current rules
list_current_rules() {
    echo ""
    echo -e "${BLUE}üìã Current IPTables Rules:${NC}"
    echo ""
    
    echo -e "${YELLOW}INPUT Chain:${NC}"
    iptables -L INPUT -n --line-numbers
    echo ""
    
    echo -e "${YELLOW}FORWARD Chain:${NC}"
    iptables -L FORWARD -n --line-numbers
    echo ""
    
    echo -e "${YELLOW}OUTPUT Chain:${NC}"
    iptables -L OUTPUT -n --line-numbers
    echo ""
}

# Test firewall rules
test_firewall_rules() {
    log "Testing firewall configuration..."
    
    # Test SSH connectivity
    if ss -tuln | grep -q ":$SSH_PORT "; then
        success "‚úì SSH port $SSH_PORT is listening"
    else
        warning "‚ö†Ô∏è  SSH port $SSH_PORT is not listening"
    fi
    
    # Test HTTP connectivity
    if ss -tuln | grep -q ":$HTTP_PORT "; then
        success "‚úì HTTP port $HTTP_PORT is listening"
    else
        warning "‚ö†Ô∏è  HTTP port $HTTP_PORT is not listening"
    fi
    
    # Test HTTPS connectivity
    if ss -tuln | grep -q ":$HTTPS_PORT "; then
        success "‚úì HTTPS port $HTTPS_PORT is listening"
    else
        warning "‚ö†Ô∏è  HTTPS port $HTTPS_PORT is not listening"
    fi
    
    # Test Docker networking
    if docker ps >/dev/null 2>&1; then
        success "‚úì Docker networking accessible"
    else
        warning "‚ö†Ô∏è  Docker networking test failed"
    fi
    
    success "Firewall testing completed"
}

# Remove all firewall rules
remove_firewall_rules() {
    warning "Removing all firewall rules..."
    
    # Set permissive policies
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    
    # Flush all rules
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t nat -X
    iptables -t mangle -F
    iptables -t mangle -X
    
    success "All firewall rules removed"
}

# Show help
show_help() {
    echo "ChitLaq Firewall Configuration Script"
    echo ""
    echo "Usage: $0 [action] [save_rules]"
    echo ""
    echo "Actions:"
    echo "  apply     Apply firewall rules (default)"
    echo "  remove    Remove all firewall rules"
    echo "  status    Show firewall status"
    echo "  list      List current rules"
    echo "  test      Test firewall configuration"
    echo ""
    echo "Arguments:"
    echo "  save_rules  Save rules for persistence (true|false) [default: true]"
    echo ""
    echo "Examples:"
    echo "  $0                    # Apply firewall rules"
    echo "  $0 apply true         # Apply and save rules"
    echo "  $0 remove false       # Remove rules without saving"
    echo "  $0 status             # Show firewall status"
    echo "  $0 list               # List current rules"
    echo "  $0 test               # Test configuration"
    echo ""
    echo "Configuration:"
    echo "  Edit .env file to configure IPs, ports, and protection settings"
}

# Main firewall function
main() {
    print_banner
    
    case "$ACTION" in
        apply)
            load_environment
            check_prerequisites
            apply_firewall_rules
            save_firewall_rules
            test_firewall_rules
            show_firewall_status
            success "üéâ Firewall configuration completed successfully!"
            ;;
        remove)
            check_prerequisites
            remove_firewall_rules
            if [ "$SAVE_RULES" = "true" ]; then
                save_firewall_rules
            fi
            warning "üö´ Firewall rules removed"
            ;;
        status)
            load_environment
            show_firewall_status
            ;;
        list)
            list_current_rules
            ;;
        test)
            load_environment
            test_firewall_rules
            ;;
        *)
            error "Unknown action: $ACTION"
            show_help
            exit 1
            ;;
    esac
}

# Handle command line arguments
case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac
