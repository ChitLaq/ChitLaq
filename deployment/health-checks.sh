#!/bin/bash

# ChitLaq M1 MVP - Comprehensive Health Check Script
# Generated by PROMPT 1.5 - CI/CD Pipeline & Automated Deployment
# Senior DevOps Engineer - 15+ years CI/CD and release management experience

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"
ENVIRONMENT=""
COMPREHENSIVE=false
TIMEOUT=60
VERBOSE=false
OUTPUT_FORMAT="text"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Health check results
declare -A HEALTH_RESULTS
TOTAL_CHECKS=0
PASSED_CHECKS=0
FAILED_CHECKS=0

# Logging functions
log_info() {
    if $VERBOSE; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Comprehensive health check script for ChitLaq M1 MVP

OPTIONS:
    --env ENVIRONMENT     Target environment (local|staging|production) (required)
    --comprehensive       Run comprehensive health checks
    --timeout SECONDS     Timeout for health checks (default: 60)
    --verbose             Enable verbose output
    --format FORMAT       Output format (text|json|xml) (default: text)
    --help                Show this help message

EXAMPLES:
    $0 --env local
    $0 --env staging --comprehensive --verbose
    $0 --env production --timeout 120 --format json

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --env)
                ENVIRONMENT="$2"
                shift 2
                ;;
            --comprehensive)
                COMPREHENSIVE=true
                shift
                ;;
            --timeout)
                TIMEOUT="$2"
                shift 2
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$ENVIRONMENT" ]]; then
        log_error "Environment is required"
        usage
        exit 1
    fi

    if [[ "$ENVIRONMENT" != "local" && "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "production" ]]; then
        log_error "Environment must be 'local', 'staging', or 'production'"
        exit 1
    fi
}

# Get environment configuration
get_environment_config() {
    case "$ENVIRONMENT" in
        local)
            export BASE_URL="http://localhost:3001"
            export DB_HOST="localhost"
            export DB_PORT="5432"
            export REDIS_HOST="localhost"
            export REDIS_PORT="6379"
            ;;
        staging)
            export BASE_URL="https://staging.chitlaq.com"
            export DB_HOST="${STAGING_DB_HOST:-staging-db.chitlaq.com}"
            export DB_PORT="${STAGING_DB_PORT:-5432}"
            export REDIS_HOST="${STAGING_REDIS_HOST:-staging-redis.chitlaq.com}"
            export REDIS_PORT="${STAGING_REDIS_PORT:-6379}"
            ;;
        production)
            export BASE_URL="https://chitlaq.com"
            export DB_HOST="${PRODUCTION_DB_HOST:-prod-db.chitlaq.com}"
            export DB_PORT="${PRODUCTION_DB_PORT:-5432}"
            export REDIS_HOST="${PRODUCTION_REDIS_HOST:-prod-redis.chitlaq.com}"
            export REDIS_PORT="${PRODUCTION_REDIS_PORT:-6379}"
            ;;
    esac
}

# Health check function
run_health_check() {
    local check_name="$1"
    local check_function="$2"
    local timeout_seconds="${3:-$TIMEOUT}"
    
    TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    
    log_info "Running health check: $check_name"
    
    # Run check with timeout
    if timeout "$timeout_seconds" bash -c "$check_function" >/dev/null 2>&1; then
        HEALTH_RESULTS["$check_name"]="PASS"
        PASSED_CHECKS=$((PASSED_CHECKS + 1))
        log_success "$check_name: PASS"
        return 0
    else
        HEALTH_RESULTS["$check_name"]="FAIL"
        FAILED_CHECKS=$((FAILED_CHECKS + 1))
        log_error "$check_name: FAIL"
        return 1
    fi
}

# Basic connectivity checks
check_http_connectivity() {
    curl -f -s --max-time 10 "$BASE_URL/health" >/dev/null
}

check_https_connectivity() {
    if [[ "$ENVIRONMENT" != "local" ]]; then
        curl -f -s --max-time 10 "$BASE_URL/health" >/dev/null
    else
        return 0
    fi
}

check_ssl_certificate() {
    if [[ "$ENVIRONMENT" != "local" ]]; then
        local domain=$(echo "$BASE_URL" | sed 's|https\?://||')
        echo | openssl s_client -servername "$domain" -connect "$domain:443" 2>/dev/null | openssl x509 -noout -dates >/dev/null
    else
        return 0
    fi
}

# API endpoint checks
check_api_health() {
    curl -f -s --max-time 10 "$BASE_URL/api/health" >/dev/null
}

check_api_auth_status() {
    curl -f -s --max-time 10 "$BASE_URL/api/auth/status" >/dev/null
}

check_api_feed() {
    curl -f -s --max-time 10 "$BASE_URL/api/feed" >/dev/null
}

check_api_search() {
    curl -f -s --max-time 10 "$BASE_URL/api/search?q=test" >/dev/null
}

check_api_users() {
    curl -f -s --max-time 10 "$BASE_URL/api/users" >/dev/null
}

# Database checks
check_database_connectivity() {
    if command -v psql &> /dev/null; then
        PGPASSWORD="${DB_PASSWORD:-postgres}" psql -h "$DB_HOST" -p "$DB_PORT" -U "${DB_USER:-postgres}" -d "${DB_NAME:-chitlaq}" -c "SELECT 1;" >/dev/null
    else
        # Fallback to Docker if psql not available
        docker exec chitlaq-postgres psql -U postgres -d chitlaq -c "SELECT 1;" >/dev/null
    fi
}

check_database_performance() {
    if command -v psql &> /dev/null; then
        PGPASSWORD="${DB_PASSWORD:-postgres}" psql -h "$DB_HOST" -p "$DB_PORT" -U "${DB_USER:-postgres}" -d "${DB_NAME:-chitlaq}" -c "SELECT pg_is_in_recovery();" >/dev/null
    else
        docker exec chitlaq-postgres psql -U postgres -d chitlaq -c "SELECT pg_is_in_recovery();" >/dev/null
    fi
}

check_database_connections() {
    if command -v psql &> /dev/null; then
        local connections=$(PGPASSWORD="${DB_PASSWORD:-postgres}" psql -h "$DB_HOST" -p "$DB_PORT" -U "${DB_USER:-postgres}" -d "${DB_NAME:-chitlaq}" -t -c "SELECT count(*) FROM pg_stat_activity;" 2>/dev/null | tr -d ' ')
        [[ "$connections" -lt 200 ]]
    else
        local connections=$(docker exec chitlaq-postgres psql -U postgres -d chitlaq -t -c "SELECT count(*) FROM pg_stat_activity;" 2>/dev/null | tr -d ' ')
        [[ "$connections" -lt 200 ]]
    fi
}

# Redis checks
check_redis_connectivity() {
    if command -v redis-cli &> /dev/null; then
        redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" ping >/dev/null
    else
        # Fallback to Docker if redis-cli not available
        docker exec chitlaq-redis redis-cli ping >/dev/null
    fi
}

check_redis_memory() {
    if command -v redis-cli &> /dev/null; then
        local memory_usage=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory | grep used_memory_human | cut -d: -f2 | tr -d '\r')
        [[ "$memory_usage" != *"M"* ]] || [[ "${memory_usage%M}" -lt 1000 ]]
    else
        local memory_usage=$(docker exec chitlaq-redis redis-cli info memory | grep used_memory_human | cut -d: -f2 | tr -d '\r')
        [[ "$memory_usage" != *"M"* ]] || [[ "${memory_usage%M}" -lt 1000 ]]
    fi
}

# WebSocket checks
check_websocket_connectivity() {
    local ws_url=$(echo "$BASE_URL" | sed 's/http/ws/')
    # Simple WebSocket connectivity test
    curl -f -s --max-time 10 -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Sec-WebSocket-Key: test" -H "Sec-WebSocket-Version: 13" "$ws_url/ws" >/dev/null || return 0
}

# Docker checks
check_docker_containers() {
    if command -v docker &> /dev/null; then
        local running_containers=$(docker ps --filter "name=chitlaq" --format "{{.Names}}" | wc -l)
        [[ "$running_containers" -gt 0 ]]
    else
        return 0
    fi
}

check_docker_health() {
    if command -v docker &> /dev/null; then
        docker ps --filter "name=chitlaq" --filter "health=unhealthy" --format "{{.Names}}" | wc -l | grep -q "^0$"
    else
        return 0
    fi
}

# System resource checks
check_system_memory() {
    local available_memory=$(free -m | awk 'NR==2{printf "%.0f", $7}')
    [[ "$available_memory" -gt 1024 ]]  # At least 1GB available
}

check_system_disk() {
    local disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    [[ "$disk_usage" -lt 90 ]]  # Less than 90% disk usage
}

check_system_cpu() {
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')
    [[ "$cpu_usage" -lt 90 ]]  # Less than 90% CPU usage
}

# Monitoring checks
check_prometheus() {
    curl -f -s --max-time 10 "$BASE_URL/metrics" >/dev/null
}

check_grafana() {
    curl -f -s --max-time 10 "$BASE_URL/grafana/api/health" >/dev/null
}

check_alertmanager() {
    curl -f -s --max-time 10 "$BASE_URL/alertmanager/api/v1/status" >/dev/null
}

# Security checks
check_security_headers() {
    local headers=$(curl -s -I --max-time 10 "$BASE_URL" | grep -i "x-frame-options\|x-content-type-options\|x-xss-protection\|strict-transport-security")
    [[ -n "$headers" ]]
}

check_rate_limiting() {
    # Test rate limiting by making multiple requests
    local response_codes=""
    for i in {1..5}; do
        response_codes+="$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$BASE_URL/api/health")"
    done
    # Should not all be 429 (rate limited)
    [[ "$response_codes" != *"429"* ]] || [[ "$response_codes" != "429429429429429" ]]
}

# Performance checks
check_response_time() {
    local response_time=$(curl -s -o /dev/null -w "%{time_total}" --max-time 10 "$BASE_URL/api/health")
    # Response time should be less than 2 seconds
    [[ $(echo "$response_time < 2.0" | bc -l) -eq 1 ]]
}

check_api_response_time() {
    local response_time=$(curl -s -o /dev/null -w "%{time_total}" --max-time 10 "$BASE_URL/api/feed")
    # API response time should be less than 5 seconds
    [[ $(echo "$response_time < 5.0" | bc -l) -eq 1 ]]
}

# Comprehensive checks
run_comprehensive_checks() {
    log_info "Running comprehensive health checks..."
    
    # Basic connectivity
    run_health_check "HTTP Connectivity" "check_http_connectivity" 10
    run_health_check "HTTPS Connectivity" "check_https_connectivity" 10
    run_health_check "SSL Certificate" "check_ssl_certificate" 15
    
    # API endpoints
    run_health_check "API Health" "check_api_health" 10
    run_health_check "API Auth Status" "check_api_auth_status" 10
    run_health_check "API Feed" "check_api_feed" 15
    run_health_check "API Search" "check_api_search" 15
    run_health_check "API Users" "check_api_users" 10
    
    # Database
    run_health_check "Database Connectivity" "check_database_connectivity" 15
    run_health_check "Database Performance" "check_database_performance" 15
    run_health_check "Database Connections" "check_database_connections" 10
    
    # Redis
    run_health_check "Redis Connectivity" "check_redis_connectivity" 10
    run_health_check "Redis Memory" "check_redis_memory" 10
    
    # WebSocket
    run_health_check "WebSocket Connectivity" "check_websocket_connectivity" 10
    
    # Docker
    run_health_check "Docker Containers" "check_docker_containers" 10
    run_health_check "Docker Health" "check_docker_health" 10
    
    # System resources
    run_health_check "System Memory" "check_system_memory" 5
    run_health_check "System Disk" "check_system_disk" 5
    run_health_check "System CPU" "check_system_cpu" 5
    
    # Monitoring
    run_health_check "Prometheus" "check_prometheus" 10
    run_health_check "Grafana" "check_grafana" 10
    run_health_check "Alertmanager" "check_alertmanager" 10
    
    # Security
    run_health_check "Security Headers" "check_security_headers" 10
    run_health_check "Rate Limiting" "check_rate_limiting" 15
    
    # Performance
    run_health_check "Response Time" "check_response_time" 10
    run_health_check "API Response Time" "check_api_response_time" 15
}

# Basic checks
run_basic_checks() {
    log_info "Running basic health checks..."
    
    # Essential checks only
    run_health_check "HTTP Connectivity" "check_http_connectivity" 10
    run_health_check "API Health" "check_api_health" 10
    run_health_check "Database Connectivity" "check_database_connectivity" 15
    run_health_check "Redis Connectivity" "check_redis_connectivity" 10
    run_health_check "Docker Containers" "check_docker_containers" 10
}

# Output functions
output_text() {
    echo "=========================================="
    echo "ChitLaq M1 MVP Health Check Results"
    echo "=========================================="
    echo "Environment: $ENVIRONMENT"
    echo "Base URL: $BASE_URL"
    echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "=========================================="
    echo ""
    
    for check_name in "${!HEALTH_RESULTS[@]}"; do
        local status="${HEALTH_RESULTS[$check_name]}"
        if [[ "$status" == "PASS" ]]; then
            echo -e "✅ $check_name: ${GREEN}PASS${NC}"
        else
            echo -e "❌ $check_name: ${RED}FAIL${NC}"
        fi
    done
    
    echo ""
    echo "=========================================="
    echo "Summary:"
    echo "Total Checks: $TOTAL_CHECKS"
    echo "Passed: $PASSED_CHECKS"
    echo "Failed: $FAILED_CHECKS"
    echo "Success Rate: $(( (PASSED_CHECKS * 100) / TOTAL_CHECKS ))%"
    echo "=========================================="
}

output_json() {
    local results=""
    for check_name in "${!HEALTH_RESULTS[@]}"; do
        local status="${HEALTH_RESULTS[$check_name]}"
        results+="    \"$check_name\": \"$status\","
    done
    results=${results%,}  # Remove trailing comma
    
    cat << EOF
{
  "environment": "$ENVIRONMENT",
  "base_url": "$BASE_URL",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "summary": {
    "total_checks": $TOTAL_CHECKS,
    "passed_checks": $PASSED_CHECKS,
    "failed_checks": $FAILED_CHECKS,
    "success_rate": $(( (PASSED_CHECKS * 100) / TOTAL_CHECKS ))
  },
  "checks": {
$results
  }
}
EOF
}

output_xml() {
    cat << EOF
<?xml version="1.0" encoding="UTF-8"?>
<healthcheck>
  <environment>$ENVIRONMENT</environment>
  <base_url>$BASE_URL</base_url>
  <timestamp>$(date -u +%Y-%m-%dT%H:%M:%SZ)</timestamp>
  <summary>
    <total_checks>$TOTAL_CHECKS</total_checks>
    <passed_checks>$PASSED_CHECKS</passed_checks>
    <failed_checks>$FAILED_CHECKS</failed_checks>
    <success_rate>$(( (PASSED_CHECKS * 100) / TOTAL_CHECKS ))</success_rate>
  </summary>
  <checks>
EOF

    for check_name in "${!HEALTH_RESULTS[@]}"; do
        local status="${HEALTH_RESULTS[$check_name]}"
        echo "    <check name=\"$check_name\" status=\"$status\" />"
    done

    cat << EOF
  </checks>
</healthcheck>
EOF
}

# Main function
main() {
    log_info "Starting health checks for environment: $ENVIRONMENT"
    
    # Get environment configuration
    get_environment_config
    
    # Run health checks
    if $COMPREHENSIVE; then
        run_comprehensive_checks
    else
        run_basic_checks
    fi
    
    # Output results
    case "$OUTPUT_FORMAT" in
        json)
            output_json
            ;;
        xml)
            output_xml
            ;;
        text|*)
            output_text
            ;;
    esac
    
    # Exit with appropriate code
    if [[ $FAILED_CHECKS -eq 0 ]]; then
        log_success "All health checks passed!"
        exit 0
    else
        log_error "$FAILED_CHECKS health check(s) failed!"
        exit 1
    fi
}

# Parse arguments and run main function
parse_args "$@"
main
