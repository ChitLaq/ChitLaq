#!/bin/bash

# ChitLaq M1 MVP - Encrypted Backup Script
# Advanced backup encryption and verification system
# Generated by PROMPT 1.2 - Security Configuration Setup

set -e  # Exit on any error
set -u  # Exit on undefined variables
set -o pipefail  # Exit on pipe failures

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENV_FILE="${PROJECT_ROOT}/.env"

# Default values
BACKUP_FILE=${1:-""}
ENCRYPTION_KEY=${2:-""}
OUTPUT_DIR=${3:-"${PROJECT_ROOT}/encrypted-backups"}
VERIFY_INTEGRITY=${4:-true}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

info() {
    echo -e "${PURPLE}[INFO]${NC} $1"
}

# Print backup encryption banner
print_banner() {
    echo -e "${PURPLE}"
    echo "  _____                             _   _             "
    echo " | ____|_ __   ___ _ __ _   _ _ __ | |_(_) ___  _ __   "
    echo " |  _| | '_ \ / __| '__| | | | '_ \| __| |/ _ \| '_ \  "
    echo " | |___| | | | (__| |  | |_| | |_) | |_| | (_) | | | | "
    echo " |_____|_| |_|\___|_|   \__, | .__/ \__|_|\___/|_| |_| "
    echo "                        |___/|_|                      "
    echo ""
    echo "ChitLaq Encrypted Backup System"
    echo "Advanced Security & Verification"
    echo "==============================="
    echo -e "${NC}"
}

# Load environment configuration
load_environment() {
    log "Loading environment configuration..."
    
    if [ -f "$ENV_FILE" ]; then
        source "$ENV_FILE"
    fi
    
    # Set encryption key from environment if not provided
    if [ -z "$ENCRYPTION_KEY" ]; then
        ENCRYPTION_KEY=${BACKUP_ENCRYPTION_KEY:-""}
    fi
    
    if [ -z "$ENCRYPTION_KEY" ]; then
        error "No encryption key provided"
        error "Set BACKUP_ENCRYPTION_KEY in .env or provide as argument"
        exit 1
    fi
    
    success "Environment configuration loaded"
}

# Check prerequisites
check_prerequisites() {
    log "Checking encryption prerequisites..."
    
    # Check if OpenSSL is available
    if ! command -v openssl >/dev/null 2>&1; then
        error "OpenSSL is not installed"
        exit 1
    fi
    
    # Check if GPG is available for additional security
    if ! command -v gpg >/dev/null 2>&1; then
        warning "GPG is not installed - using OpenSSL only"
        USE_GPG=false
    else
        USE_GPG=true
    fi
    
    # Check if backup file exists
    if [ -n "$BACKUP_FILE" ] && [ ! -f "$BACKUP_FILE" ]; then
        error "Backup file not found: $BACKUP_FILE"
        exit 1
    fi
    
    # Create output directory
    mkdir -p "$OUTPUT_DIR"
    
    success "Prerequisites check passed"
}

# Generate secure random salt
generate_salt() {
    openssl rand -hex 32
}

# Generate secure IV for AES
generate_iv() {
    openssl rand -hex 16
}

# Derive key from password using PBKDF2
derive_key() {
    local password="$1"
    local salt="$2"
    local iterations=100000
    
    echo -n "$password" | openssl dgst -sha256 -pbkdf2 -iter $iterations -salt "$salt" | cut -d' ' -f2
}

# Calculate file hash for integrity verification
calculate_hash() {
    local file="$1"
    local algorithm="${2:-sha256}"
    
    openssl dgst -"$algorithm" "$file" | cut -d' ' -f2
}

# Encrypt file using OpenSSL AES-256-GCM
encrypt_with_openssl() {
    local input_file="$1"
    local output_file="$2"
    local key="$3"
    
    log "Encrypting with OpenSSL AES-256-GCM..."
    
    # Generate salt and IV
    local salt=$(generate_salt)
    local iv=$(generate_iv)
    
    # Derive encryption key
    local derived_key=$(derive_key "$key" "$salt")
    
    # Create metadata header
    local metadata=$(cat << EOF
{
    "version": "1.0",
    "algorithm": "AES-256-GCM",
    "salt": "$salt",
    "iv": "$iv",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "original_file": "$(basename "$input_file")",
    "original_size": $(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file"),
    "original_hash": "$(calculate_hash "$input_file")"
}
EOF
)
    
    # Create temporary files
    local temp_metadata="/tmp/backup_metadata_$$"
    local temp_encrypted="/tmp/backup_encrypted_$$"
    
    # Write metadata
    echo "$metadata" > "$temp_metadata"
    
    # Encrypt the file
    openssl enc -aes-256-gcm \
        -in "$input_file" \
        -out "$temp_encrypted" \
        -K "$derived_key" \
        -iv "$iv" \
        -aad "ChitLaq-Backup-v1.0"
    
    if [ $? -eq 0 ]; then
        # Combine metadata and encrypted data
        {
            printf "CHITLAQ_BACKUP_V1.0\n"
            printf "METADATA_START\n"
            cat "$temp_metadata"
            printf "\nMETADATA_END\n"
            printf "DATA_START\n"
            cat "$temp_encrypted"
            printf "\nDATA_END\n"
        } > "$output_file"
        
        # Cleanup
        rm -f "$temp_metadata" "$temp_encrypted"
        
        success "OpenSSL encryption completed"
        return 0
    else
        # Cleanup on failure
        rm -f "$temp_metadata" "$temp_encrypted"
        error "OpenSSL encryption failed"
        return 1
    fi
}

# Encrypt file using GPG (additional layer)
encrypt_with_gpg() {
    local input_file="$1"
    local output_file="$2"
    local passphrase="$3"
    
    log "Adding GPG encryption layer..."
    
    # Encrypt with GPG using AES256 cipher
    gpg --cipher-algo AES256 \
        --compress-algo 2 \
        --s2k-mode 3 \
        --s2k-digest-algo SHA256 \
        --s2k-count 65011712 \
        --force-mdc \
        --batch \
        --yes \
        --passphrase "$passphrase" \
        --symmetric \
        --armor \
        --output "$output_file" \
        "$input_file"
    
    if [ $? -eq 0 ]; then
        success "GPG encryption completed"
        return 0
    else
        error "GPG encryption failed"
        return 1
    fi
}

# Compress file before encryption
compress_file() {
    local input_file="$1"
    local output_file="$2"
    
    log "Compressing backup file..."
    
    # Use gzip with maximum compression
    gzip -9c "$input_file" > "$output_file"
    
    if [ $? -eq 0 ]; then
        local original_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file")
        local compressed_size=$(stat -f%z "$output_file" 2>/dev/null || stat -c%s "$output_file")
        local compression_ratio=$(echo "scale=2; $compressed_size * 100 / $original_size" | bc -l)
        
        success "Compression completed (${compression_ratio}% of original size)"
        return 0
    else
        error "Compression failed"
        return 1
    fi
}

# Verify encrypted backup integrity
verify_backup_integrity() {
    local encrypted_file="$1"
    local original_hash="$2"
    
    if [ "$VERIFY_INTEGRITY" != "true" ]; then
        log "Integrity verification disabled, skipping..."
        return 0
    fi
    
    log "Verifying backup integrity..."
    
    # Extract metadata from encrypted file
    local metadata_start=$(grep -n "METADATA_START" "$encrypted_file" | cut -d: -f1)
    local metadata_end=$(grep -n "METADATA_END" "$encrypted_file" | cut -d: -f1)
    
    if [ -z "$metadata_start" ] || [ -z "$metadata_end" ]; then
        error "Cannot find metadata in encrypted file"
        return 1
    fi
    
    # Extract and parse metadata
    local metadata=$(sed -n "$((metadata_start + 1)),$((metadata_end - 1))p" "$encrypted_file")
    local stored_hash=$(echo "$metadata" | grep "original_hash" | cut -d'"' -f4)
    
    if [ "$stored_hash" = "$original_hash" ]; then
        success "Backup integrity verified"
        return 0
    else
        error "Backup integrity verification failed"
        error "Expected: $original_hash"
        error "Found: $stored_hash"
        return 1
    fi
}

# Generate backup report
generate_backup_report() {
    local input_file="$1"
    local encrypted_file="$2"
    local compression_used="$3"
    local gpg_used="$4"
    
    local report_file="${OUTPUT_DIR}/backup-report-$(date +%Y%m%d_%H%M%S).txt"
    
    log "Generating encryption report..."
    
    # Calculate file sizes
    local original_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file")
    local encrypted_size=$(stat -f%z "$encrypted_file" 2>/dev/null || stat -c%s "$encrypted_file")
    
    # Calculate file hashes
    local original_hash=$(calculate_hash "$input_file")
    local encrypted_hash=$(calculate_hash "$encrypted_file")
    
    cat > "$report_file" << EOF
ChitLaq Encrypted Backup Report
===============================
Generated: $(date)

File Information:
- Original File: $(basename "$input_file")
- Encrypted File: $(basename "$encrypted_file")
- Original Size: $(numfmt --to=iec "$original_size")
- Encrypted Size: $(numfmt --to=iec "$encrypted_size")
- Size Overhead: $(echo "scale=2; ($encrypted_size - $original_size) * 100 / $original_size" | bc -l)%

Security Features:
- Encryption Algorithm: AES-256-GCM
- Key Derivation: PBKDF2-SHA256 (100,000 iterations)
- Compression: $([ "$compression_used" = "true" ] && echo "Enabled (gzip)" || echo "Disabled")
- GPG Layer: $([ "$gpg_used" = "true" ] && echo "Enabled" || echo "Disabled")
- Integrity Verification: $([ "$VERIFY_INTEGRITY" = "true" ] && echo "Enabled" || echo "Disabled")

File Hashes:
- Original File (SHA256): $original_hash
- Encrypted File (SHA256): $encrypted_hash

Metadata:
- Backup Tool: ChitLaq Encrypted Backup v1.0
- Encryption Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- Environment: $([ -n "${NODE_ENV:-}" ] && echo "$NODE_ENV" || echo "Unknown")

Security Notes:
- Store encryption key separately from backup
- Verify backup integrity before relying on it
- Test decryption process regularly
- Consider offsite backup storage

Recovery Instructions:
1. Use decrypt-backup.sh to decrypt the file
2. Provide the same encryption key used for encryption
3. Verify file integrity after decryption
4. Extract compressed content if compression was used

Contact Information:
- Security Team: security@chitlaq.com
- Backup Administrator: admin@chitlaq.com
EOF

    success "Backup report generated: $(basename "$report_file")"
    echo "$report_file"
}

# Create backup checksum file
create_checksum_file() {
    local encrypted_file="$1"
    local checksum_file="${encrypted_file}.sha256"
    
    log "Creating checksum file..."
    
    # Generate multiple checksums for verification
    {
        echo "# ChitLaq Encrypted Backup Checksums"
        echo "# Generated: $(date)"
        echo "# File: $(basename "$encrypted_file")"
        echo ""
        echo "# SHA256:"
        calculate_hash "$encrypted_file" sha256
        echo ""
        echo "# SHA512:"
        calculate_hash "$encrypted_file" sha512
        echo ""
        echo "# MD5 (for compatibility):"
        calculate_hash "$encrypted_file" md5
    } > "$checksum_file"
    
    success "Checksum file created: $(basename "$checksum_file")"
}

# Encrypt single backup file
encrypt_backup_file() {
    local input_file="$1"
    
    if [ ! -f "$input_file" ]; then
        error "Input file not found: $input_file"
        return 1
    fi
    
    log "Starting encryption of: $(basename "$input_file")"
    
    # Generate output filename
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local basename_no_ext=$(basename "$input_file" | sed 's/\.[^.]*$//')
    local encrypted_file="${OUTPUT_DIR}/${basename_no_ext}_encrypted_${timestamp}.chitlaq"
    
    # Calculate original hash
    local original_hash=$(calculate_hash "$input_file")
    log "Original file hash: $original_hash"
    
    # Compress if beneficial
    local compression_used=false
    local temp_compressed="/tmp/backup_compressed_$$"
    
    if compress_file "$input_file" "$temp_compressed"; then
        local original_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file")
        local compressed_size=$(stat -f%z "$temp_compressed" 2>/dev/null || stat -c%s "$temp_compressed")
        
        # Use compression if it reduces size by at least 10%
        if [ $compressed_size -lt $((original_size * 90 / 100)) ]; then
            input_file="$temp_compressed"
            compression_used=true
            log "Using compressed version for encryption"
        else
            rm -f "$temp_compressed"
            log "Compression not beneficial, using original file"
        fi
    fi
    
    # Encrypt with OpenSSL
    if encrypt_with_openssl "$input_file" "$encrypted_file" "$ENCRYPTION_KEY"; then
        local gpg_used=false
        
        # Add GPG layer if available
        if [ "$USE_GPG" = "true" ]; then
            local temp_gpg="${encrypted_file}.gpg"
            if encrypt_with_gpg "$encrypted_file" "$temp_gpg" "$ENCRYPTION_KEY"; then
                mv "$temp_gpg" "$encrypted_file"
                gpg_used=true
            else
                warning "GPG encryption failed, continuing with OpenSSL only"
            fi
        fi
        
        # Verify integrity
        if verify_backup_integrity "$encrypted_file" "$original_hash"; then
            # Create checksum file
            create_checksum_file "$encrypted_file"
            
            # Generate report
            local report_file=$(generate_backup_report "$1" "$encrypted_file" "$compression_used" "$gpg_used")
            
            # Cleanup temporary files
            rm -f "$temp_compressed"
            
            # Show results
            local encrypted_size=$(stat -f%z "$encrypted_file" 2>/dev/null || stat -c%s "$encrypted_file")
            success "Backup encryption completed successfully"
            success "Encrypted file: $(basename "$encrypted_file")"
            success "Encrypted size: $(numfmt --to=iec "$encrypted_size")"
            success "Report: $(basename "$report_file")"
            
            return 0
        else
            error "Backup integrity verification failed"
            rm -f "$encrypted_file"
            return 1
        fi
    else
        error "Backup encryption failed"
        rm -f "$temp_compressed"
        return 1
    fi
}

# Encrypt all backup files in directory
encrypt_all_backups() {
    local backup_dir="${1:-${PROJECT_ROOT}/backups}"
    
    if [ ! -d "$backup_dir" ]; then
        error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    log "Encrypting all backups in: $backup_dir"
    
    local success_count=0
    local error_count=0
    
    # Find all backup files
    find "$backup_dir" -type f \( -name "*.sql.gz" -o -name "*.rdb.gz" -o -name "*.tar.gz" \) | while read -r backup_file; do
        if encrypt_backup_file "$backup_file"; then
            ((success_count++))
        else
            ((error_count++))
        fi
    done
    
    log "Encryption completed: $success_count successful, $error_count failed"
}

# Show encryption status
show_encryption_status() {
    echo ""
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}🔐 ChitLaq Backup Encryption Status${NC}"
    echo -e "${GREEN}================================================${NC}"
    echo ""
    
    echo -e "${BLUE}📁 Directories:${NC}"
    echo "  📂 Output: $OUTPUT_DIR"
    echo "  📂 Source: $(dirname "$BACKUP_FILE")"
    echo ""
    
    echo -e "${BLUE}🔧 Encryption Settings:${NC}"
    echo "  🔐 Algorithm: AES-256-GCM + PBKDF2-SHA256"
    echo "  📊 Compression: Enabled (gzip)"
    echo "  🛡️  GPG Layer: $([ "$USE_GPG" = "true" ] && echo "Available" || echo "Not Available")"
    echo "  ✅ Integrity Check: $([ "$VERIFY_INTEGRITY" = "true" ] && echo "Enabled" || echo "Disabled")"
    echo ""
    
    echo -e "${BLUE}📈 Statistics:${NC}"
    if [ -d "$OUTPUT_DIR" ]; then
        local encrypted_count=$(find "$OUTPUT_DIR" -name "*.chitlaq" | wc -l)
        local total_size=$(find "$OUTPUT_DIR" -name "*.chitlaq" -exec stat -f%z {} + 2>/dev/null | awk '{sum+=$1} END {print sum}' || echo "0")
        echo "  🔐 Encrypted Files: $encrypted_count"
        echo "  💾 Total Size: $(numfmt --to=iec "${total_size:-0}")"
    else
        echo "  📊 No encrypted backups found"
    fi
    echo ""
    
    echo -e "${GREEN}✅ Encryption Status: READY${NC}"
    echo ""
}

# Show help
show_help() {
    echo "ChitLaq Encrypted Backup Script"
    echo ""
    echo "Usage: $0 [backup_file] [encryption_key] [output_dir] [verify_integrity]"
    echo ""
    echo "Arguments:"
    echo "  backup_file       Path to backup file to encrypt [required]"
    echo "  encryption_key    Encryption key (or set BACKUP_ENCRYPTION_KEY in .env)"
    echo "  output_dir        Output directory [default: ./encrypted-backups]"
    echo "  verify_integrity  Verify backup integrity (true|false) [default: true]"
    echo ""
    echo "Examples:"
    echo "  $0 backups/postgres_20240101.sql.gz"
    echo "  $0 backups/postgres_20240101.sql.gz \"my-secure-key\""
    echo "  $0 backups/redis_20240101.rdb.gz \"key\" /secure/backups"
    echo ""
    echo "Special modes:"
    echo "  $0 --encrypt-all                  # Encrypt all files in backups/"
    echo "  $0 --status                       # Show encryption status"
    echo ""
    echo "Prerequisites:"
    echo "  - OpenSSL installed"
    echo "  - GPG installed (optional, for additional security)"
    echo "  - BACKUP_ENCRYPTION_KEY set in .env"
}

# Main encryption function
main() {
    print_banner
    
    # Handle special modes
    case "${1:-}" in
        --encrypt-all)
            load_environment
            check_prerequisites
            encrypt_all_backups
            show_encryption_status
            return 0
            ;;
        --status)
            load_environment
            show_encryption_status
            return 0
            ;;
        "")
            error "No backup file specified"
            show_help
            exit 1
            ;;
    esac
    
    # Load configuration
    load_environment
    
    # Check prerequisites
    check_prerequisites
    
    # Encrypt backup file
    if encrypt_backup_file "$BACKUP_FILE"; then
        show_encryption_status
        success "🎉 Backup encryption completed successfully!"
    else
        error "❌ Backup encryption failed"
        exit 1
    fi
}

# Handle command line arguments
case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac
