// ChitLaq M1 MVP - Custom Metrics Collection
// Business and application-specific metrics for Prometheus
// Generated by PROMPT 1.4 - Monitoring & Observability Stack

const promClient = require('prom-client');
const { register } = promClient;

// ===============================
// METRIC DEFINITIONS
// ===============================

// Business Metrics
const userRegistrations = new promClient.Counter({
  name: 'chitlaq_user_registrations_total',
  help: 'Total number of user registrations',
  labelNames: ['university_domain', 'registration_method']
});

const activeUsers = new promClient.Gauge({
  name: 'chitlaq_active_users',
  help: 'Number of currently active users',
  labelNames: ['time_window']
});

const postsCreated = new promClient.Counter({
  name: 'chitlaq_posts_created_total',
  help: 'Total number of posts created',
  labelNames: ['content_type', 'privacy_level']
});

const messagesSent = new promClient.Counter({
  name: 'chitlaq_messages_sent_total',
  help: 'Total number of messages sent',
  labelNames: ['message_type', 'conversation_type']
});

const userEngagement = new promClient.Histogram({
  name: 'chitlaq_user_engagement_duration_seconds',
  help: 'Duration of user engagement sessions',
  labelNames: ['engagement_type'],
  buckets: [1, 5, 15, 30, 60, 300, 900, 1800, 3600]
});

// Application Performance Metrics
const apiResponseTime = new promClient.Histogram({
  name: 'chitlaq_api_response_time_seconds',
  help: 'API response time in seconds',
  labelNames: ['method', 'endpoint', 'status_code'],
  buckets: [0.1, 0.25, 0.5, 1, 2.5, 5, 10]
});

const databaseQueryTime = new promClient.Histogram({
  name: 'chitlaq_database_query_time_seconds',
  help: 'Database query execution time',
  labelNames: ['query_type', 'table_name'],
  buckets: [0.01, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5]
});

const websocketConnections = new promClient.Gauge({
  name: 'chitlaq_websocket_connections_active',
  help: 'Number of active WebSocket connections',
  labelNames: ['connection_type']
});

const feedGenerationTime = new promClient.Histogram({
  name: 'chitlaq_feed_generation_time_seconds',
  help: 'Time taken to generate user feeds',
  labelNames: ['feed_type', 'algorithm_version'],
  buckets: [0.1, 0.25, 0.5, 1, 2, 5, 10]
});

// System Health Metrics
const cacheHitRatio = new promClient.Gauge({
  name: 'chitlaq_cache_hit_ratio',
  help: 'Cache hit ratio percentage',
  labelNames: ['cache_type']
});

const queueDepth = new promClient.Gauge({
  name: 'chitlaq_queue_depth',
  help: 'Number of items in processing queues',
  labelNames: ['queue_name', 'priority']
});

const errorRate = new promClient.Counter({
  name: 'chitlaq_errors_total',
  help: 'Total number of errors',
  labelNames: ['error_type', 'service', 'severity']
});

// Security Metrics
const failedLogins = new promClient.Counter({
  name: 'chitlaq_failed_logins_total',
  help: 'Total number of failed login attempts',
  labelNames: ['ip_address', 'user_agent_type']
});

const rateLimitHits = new promClient.Counter({
  name: 'chitlaq_rate_limit_hits_total',
  help: 'Total number of rate limit violations',
  labelNames: ['endpoint', 'client_ip']
});

const suspiciousActivity = new promClient.Counter({
  name: 'chitlaq_suspicious_activity_total',
  help: 'Total number of suspicious activities detected',
  labelNames: ['activity_type', 'severity']
});

// Content Metrics
const contentModeration = new promClient.Counter({
  name: 'chitlaq_content_moderation_total',
  help: 'Total content moderation actions',
  labelNames: ['action_type', 'content_type', 'moderator_type']
});

const hashtagUsage = new promClient.Counter({
  name: 'chitlaq_hashtag_usage_total',
  help: 'Total hashtag usage count',
  labelNames: ['hashtag', 'category']
});

const searchQueries = new promClient.Counter({
  name: 'chitlaq_search_queries_total',
  help: 'Total number of search queries',
  labelNames: ['search_type', 'result_count_range']
});

// ===============================
// METRIC COLLECTION FUNCTIONS
// ===============================

class MetricsCollector {
  constructor() {
    this.startTime = Date.now();
    this.initializeMetrics();
  }

  initializeMetrics() {
    // Set up default metrics
    promClient.collectDefaultMetrics({ register });
    
    // Initialize custom metrics
    this.updateSystemMetrics();
    
    // Set up periodic metric updates
    setInterval(() => {
      this.updateSystemMetrics();
    }, 30000); // Update every 30 seconds
  }

  // Business Metrics
  recordUserRegistration(universityDomain, registrationMethod = 'email') {
    userRegistrations.inc({ university_domain: universityDomain, registration_method: registrationMethod });
  }

  recordPostCreation(contentType = 'text', privacyLevel = 'public') {
    postsCreated.inc({ content_type: contentType, privacy_level: privacyLevel });
  }

  recordMessageSent(messageType = 'text', conversationType = 'direct') {
    messagesSent.inc({ message_type: messageType, conversation_type: conversationType });
  }

  recordUserEngagement(engagementType, durationSeconds) {
    userEngagement.observe({ engagement_type: engagementType }, durationSeconds);
  }

  updateActiveUsers(count, timeWindow = '1h') {
    activeUsers.set({ time_window: timeWindow }, count);
  }

  // Performance Metrics
  recordApiResponseTime(method, endpoint, statusCode, durationSeconds) {
    apiResponseTime.observe({ method, endpoint, status_code: statusCode }, durationSeconds);
  }

  recordDatabaseQueryTime(queryType, tableName, durationSeconds) {
    databaseQueryTime.observe({ query_type: queryType, table_name: tableName }, durationSeconds);
  }

  updateWebSocketConnections(count, connectionType = 'user') {
    websocketConnections.set({ connection_type: connectionType }, count);
  }

  recordFeedGenerationTime(feedType, algorithmVersion, durationSeconds) {
    feedGenerationTime.observe({ feed_type: feedType, algorithm_version: algorithmVersion }, durationSeconds);
  }

  // System Metrics
  updateCacheHitRatio(ratio, cacheType) {
    cacheHitRatio.set({ cache_type: cacheType }, ratio);
  }

  updateQueueDepth(depth, queueName, priority = 'normal') {
    queueDepth.set({ queue_name: queueName, priority }, depth);
  }

  recordError(errorType, service, severity = 'error') {
    errorRate.inc({ error_type: errorType, service, severity });
  }

  // Security Metrics
  recordFailedLogin(ipAddress, userAgentType = 'unknown') {
    failedLogins.inc({ ip_address: ipAddress, user_agent_type: userAgentType });
  }

  recordRateLimitHit(endpoint, clientIp) {
    rateLimitHits.inc({ endpoint, client_ip: clientIp });
  }

  recordSuspiciousActivity(activityType, severity = 'medium') {
    suspiciousActivity.inc({ activity_type: activityType, severity });
  }

  // Content Metrics
  recordContentModeration(actionType, contentType, moderatorType = 'automated') {
    contentModeration.inc({ action_type: actionType, content_type: contentType, moderator_type: moderatorType });
  }

  recordHashtagUsage(hashtag, category = 'general') {
    hashtagUsage.inc({ hashtag, category });
  }

  recordSearchQuery(searchType, resultCount) {
    let resultCountRange = '0';
    if (resultCount > 0 && resultCount <= 10) resultCountRange = '1-10';
    else if (resultCount > 10 && resultCount <= 50) resultCountRange = '11-50';
    else if (resultCount > 50 && resultCount <= 100) resultCountRange = '51-100';
    else if (resultCount > 100) resultCountRange = '100+';
    
    searchQueries.inc({ search_type: searchType, result_count_range: resultCountRange });
  }

  // System Health Updates
  updateSystemMetrics() {
    // Update uptime
    const uptime = (Date.now() - this.startTime) / 1000;
    
    // Update memory usage
    const memUsage = process.memoryUsage();
    const memUsageMB = memUsage.heapUsed / 1024 / 1024;
    
    // Update event loop lag
    const start = process.hrtime.bigint();
    setImmediate(() => {
      const delta = process.hrtime.bigint() - start;
      const nanosec = Number(delta);
      const millisec = nanosec / 1000000;
      
      // Record event loop lag
      if (millisec > 10) { // Only record if lag is significant
        this.recordError('event_loop_lag', 'nodejs', 'warning');
      }
    });
  }

  // Database Metrics Collection
  async collectDatabaseMetrics(db) {
    try {
      // Active connections
      const activeConnections = await db.query('SELECT count(*) FROM pg_stat_activity WHERE state = \'active\'');
      
      // Cache hit ratio
      const cacheStats = await db.query(`
        SELECT 
          round(100.0 * sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)), 2) as hit_ratio
        FROM pg_statio_user_tables
      `);
      
      if (cacheStats.rows[0]) {
        this.updateCacheHitRatio(cacheStats.rows[0].hit_ratio, 'postgresql');
      }
      
      // Database size
      const dbSize = await db.query(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as size,
               pg_database_size(current_database()) as size_bytes
      `);
      
      // Long running queries
      const longQueries = await db.query(`
        SELECT count(*) as count
        FROM pg_stat_activity 
        WHERE state = 'active' 
        AND now() - query_start > interval '5 minutes'
      `);
      
      if (longQueries.rows[0] && longQueries.rows[0].count > 0) {
        this.recordError('long_running_query', 'postgresql', 'warning');
      }
      
    } catch (error) {
      this.recordError('database_metrics_collection', 'postgresql', 'error');
      console.error('Error collecting database metrics:', error);
    }
  }

  // Redis Metrics Collection
  async collectRedisMetrics(redis) {
    try {
      const info = await redis.info();
      const lines = info.split('\r\n');
      const metrics = {};
      
      lines.forEach(line => {
        if (line.includes(':')) {
          const [key, value] = line.split(':');
          metrics[key] = value;
        }
      });
      
      // Update cache hit ratio
      if (metrics.keyspace_hits && metrics.keyspace_misses) {
        const hits = parseInt(metrics.keyspace_hits);
        const misses = parseInt(metrics.keyspace_misses);
        const ratio = (hits / (hits + misses)) * 100;
        this.updateCacheHitRatio(ratio, 'redis');
      }
      
      // Update memory usage
      if (metrics.used_memory) {
        const usedMemoryMB = parseInt(metrics.used_memory) / 1024 / 1024;
        // Could add a memory usage gauge here
      }
      
    } catch (error) {
      this.recordError('redis_metrics_collection', 'redis', 'error');
      console.error('Error collecting Redis metrics:', error);
    }
  }

  // Get metrics for Prometheus scraping
  getMetrics() {
    return register.metrics();
  }

  // Get metrics in JSON format
  getMetricsAsJSON() {
    return register.getMetricsAsJSON();
  }
}

// ===============================
// EXPRESS MIDDLEWARE
// ===============================

function metricsMiddleware(req, res, next) {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    const method = req.method;
    const endpoint = req.route ? req.route.path : req.path;
    const statusCode = res.statusCode;
    
    metricsCollector.recordApiResponseTime(method, endpoint, statusCode, duration);
    
    // Record errors
    if (statusCode >= 400) {
      const errorType = statusCode >= 500 ? 'server_error' : 'client_error';
      metricsCollector.recordError(errorType, 'api', 'error');
    }
  });
  
  next();
}

// ===============================
// EXPORTS
// ===============================

const metricsCollector = new MetricsCollector();

module.exports = {
  MetricsCollector,
  metricsCollector,
  metricsMiddleware,
  register,
  
  // Individual metrics for direct access
  userRegistrations,
  activeUsers,
  postsCreated,
  messagesSent,
  userEngagement,
  apiResponseTime,
  databaseQueryTime,
  websocketConnections,
  feedGenerationTime,
  cacheHitRatio,
  queueDepth,
  errorRate,
  failedLogins,
  rateLimitHits,
  suspiciousActivity,
  contentModeration,
  hashtagUsage,
  searchQueries
};
