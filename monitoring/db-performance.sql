-- ChitLaq M1 MVP - Database Performance Monitoring Queries
-- SQL queries for monitoring PostgreSQL performance and optimization
-- Generated by PROMPT 1.3 - Database Schema & Migrations

-- ===============================
-- TABLE AND INDEX USAGE STATISTICS
-- ===============================

-- Table usage statistics with read/write ratios
CREATE OR REPLACE VIEW v_table_usage_stats AS
SELECT 
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins as inserts,
    n_tup_upd as updates,
    n_tup_del as deletes,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    CASE 
        WHEN seq_scan + idx_scan > 0 
        THEN ROUND((idx_scan::numeric / (seq_scan + idx_scan)) * 100, 2)
        ELSE 0 
    END as index_usage_ratio,
    CASE 
        WHEN n_live_tup > 0 
        THEN ROUND((n_dead_tup::numeric / n_live_tup) * 100, 2)
        ELSE 0 
    END as dead_tuple_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY seq_scan + idx_scan DESC;

-- Index usage statistics
CREATE OR REPLACE VIEW v_index_usage_stats AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan as times_used,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    CASE 
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_scan < 100 THEN 'LOW_USAGE'
        WHEN idx_scan < 1000 THEN 'MEDIUM_USAGE'
        ELSE 'HIGH_USAGE'
    END as usage_category
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- Unused indexes (potential candidates for removal)
CREATE OR REPLACE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    pg_relation_size(indexrelid) as size_bytes
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexname NOT LIKE '%_pkey'  -- Keep primary keys
ORDER BY pg_relation_size(indexrelid) DESC;

-- ===============================
-- QUERY PERFORMANCE MONITORING
-- ===============================

-- Slowest queries (requires pg_stat_statements extension)
CREATE OR REPLACE VIEW v_slow_queries AS
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    stddev_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent,
    100.0 * (total_time / sum(total_time) OVER()) AS time_percent
FROM pg_stat_statements
WHERE query NOT LIKE '%pg_stat_statements%'
    AND query NOT LIKE '%information_schema%'
ORDER BY total_time DESC
LIMIT 20;

-- Most frequent queries
CREATE OR REPLACE VIEW v_frequent_queries AS
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    100.0 * (calls / sum(calls) OVER()) AS call_percent
FROM pg_stat_statements
WHERE query NOT LIKE '%pg_stat_statements%'
    AND query NOT LIKE '%information_schema%'
ORDER BY calls DESC
LIMIT 20;

-- ===============================
-- CONNECTION AND ACTIVITY MONITORING
-- ===============================

-- Current database connections
CREATE OR REPLACE VIEW v_current_connections AS
SELECT 
    datname as database,
    usename as username,
    client_addr,
    client_port,
    application_name,
    state,
    query_start,
    state_change,
    NOW() - query_start as query_duration,
    NOW() - state_change as state_duration,
    query
FROM pg_stat_activity
WHERE state != 'idle'
    AND pid != pg_backend_pid()
ORDER BY query_start;

-- Connection statistics by database
CREATE OR REPLACE VIEW v_connection_stats AS
SELECT 
    datname as database,
    count(*) as total_connections,
    count(*) FILTER (WHERE state = 'active') as active_connections,
    count(*) FILTER (WHERE state = 'idle') as idle_connections,
    count(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction,
    count(*) FILTER (WHERE state = 'idle in transaction (aborted)') as idle_in_transaction_aborted
FROM pg_stat_activity
GROUP BY datname
ORDER BY total_connections DESC;

-- Long running queries (over 1 minute)
CREATE OR REPLACE VIEW v_long_running_queries AS
SELECT 
    pid,
    usename,
    datname,
    client_addr,
    application_name,
    state,
    query_start,
    NOW() - query_start as duration,
    query
FROM pg_stat_activity
WHERE state != 'idle'
    AND NOW() - query_start > INTERVAL '1 minute'
    AND pid != pg_backend_pid()
ORDER BY query_start;

-- ===============================
-- LOCK MONITORING
-- ===============================

-- Current locks
CREATE OR REPLACE VIEW v_current_locks AS
SELECT 
    l.mode,
    l.locktype,
    l.database,
    l.relation,
    l.page,
    l.tuple,
    l.classid,
    l.granted,
    a.query,
    a.query_start,
    age(now(), a.query_start) AS "age",
    a.pid
FROM pg_locks l
LEFT JOIN pg_stat_activity a ON l.pid = a.pid
WHERE a.datname = current_database()
ORDER BY a.query_start;

-- Blocking queries
CREATE OR REPLACE VIEW v_blocking_queries AS
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS current_statement_in_blocking_process,
    blocked_activity.application_name AS blocked_application,
    blocking_activity.application_name AS blocking_application
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- ===============================
-- CACHE AND BUFFER STATISTICS
-- ===============================

-- Buffer cache hit ratio
CREATE OR REPLACE VIEW v_cache_hit_ratio AS
SELECT 
    'buffer_cache' as cache_type,
    sum(heap_blks_hit) as cache_hits,
    sum(heap_blks_read) as disk_reads,
    CASE 
        WHEN sum(heap_blks_hit) + sum(heap_blks_read) = 0 THEN 0
        ELSE round(
            sum(heap_blks_hit)::numeric / 
            (sum(heap_blks_hit) + sum(heap_blks_read)) * 100, 2
        )
    END as hit_ratio_percent
FROM pg_statio_user_tables

UNION ALL

SELECT 
    'index_cache' as cache_type,
    sum(idx_blks_hit) as cache_hits,
    sum(idx_blks_read) as disk_reads,
    CASE 
        WHEN sum(idx_blks_hit) + sum(idx_blks_read) = 0 THEN 0
        ELSE round(
            sum(idx_blks_hit)::numeric / 
            (sum(idx_blks_hit) + sum(idx_blks_read)) * 100, 2
        )
    END as hit_ratio_percent
FROM pg_statio_user_indexes;

-- ===============================
-- DATABASE SIZE AND GROWTH
-- ===============================

-- Database sizes
CREATE OR REPLACE VIEW v_database_sizes AS
SELECT 
    d.datname as database_name,
    pg_catalog.pg_get_userbyid(d.datdba) as owner,
    pg_size_pretty(pg_database_size(d.datname)) as size,
    pg_database_size(d.datname) as size_bytes
FROM pg_catalog.pg_database d
ORDER BY pg_database_size(d.datname) DESC;

-- Table sizes with indexes
CREATE OR REPLACE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - 
                   pg_relation_size(schemaname||'.'||tablename)) as index_size,
    pg_total_relation_size(schemaname||'.'||tablename) as total_size_bytes,
    (pg_total_relation_size(schemaname||'.'||tablename) - 
     pg_relation_size(schemaname||'.'||tablename)) as index_size_bytes
FROM pg_tables
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- ===============================
-- VACUUM AND ANALYZE STATISTICS
-- ===============================

-- Tables that need vacuuming
CREATE OR REPLACE VIEW v_vacuum_needed AS
SELECT 
    schemaname,
    tablename,
    n_dead_tup,
    n_live_tup,
    CASE 
        WHEN n_live_tup > 0 
        THEN round((n_dead_tup::numeric / n_live_tup) * 100, 2)
        ELSE 0 
    END as dead_tuple_ratio,
    last_vacuum,
    last_autovacuum,
    NOW() - last_autovacuum as time_since_last_vacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
    OR (n_live_tup > 0 AND (n_dead_tup::numeric / n_live_tup) > 0.1)
ORDER BY dead_tuple_ratio DESC;

-- Tables that need analyzing
CREATE OR REPLACE VIEW v_analyze_needed AS
SELECT 
    schemaname,
    tablename,
    n_mod_since_analyze,
    last_analyze,
    last_autoanalyze,
    NOW() - last_autoanalyze as time_since_last_analyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 1000
    OR last_autoanalyze < NOW() - INTERVAL '1 day'
ORDER BY n_mod_since_analyze DESC;

-- ===============================
-- REPLICATION AND BACKUP STATUS
-- ===============================

-- Replication lag (if using streaming replication)
CREATE OR REPLACE VIEW v_replication_lag AS
SELECT 
    client_addr,
    application_name,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    write_lag,
    flush_lag,
    replay_lag,
    sync_state,
    sync_priority
FROM pg_stat_replication;

-- WAL files and archiving status
CREATE OR REPLACE VIEW v_wal_status AS
SELECT 
    name,
    setting,
    unit,
    context,
    vartype,
    source,
    min_val,
    max_val,
    enumvals,
    boot_val,
    reset_val,
    sourcefile,
    sourceline,
    pending_restart
FROM pg_settings
WHERE name IN (
    'wal_level',
    'archive_mode',
    'archive_command',
    'max_wal_size',
    'min_wal_size',
    'wal_compression',
    'wal_buffers'
);

-- ===============================
-- PERFORMANCE MONITORING FUNCTIONS
-- ===============================

-- Function to get current performance snapshot
CREATE OR REPLACE FUNCTION get_performance_snapshot()
RETURNS TABLE (
    metric_name text,
    metric_value numeric,
    metric_unit text,
    timestamp_taken timestamptz
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'active_connections'::text,
        (SELECT count(*)::numeric FROM pg_stat_activity WHERE state = 'active'),
        'connections'::text,
        NOW();
    
    RETURN QUERY
    SELECT 
        'cache_hit_ratio'::text,
        (SELECT 
            CASE 
                WHEN sum(heap_blks_hit) + sum(heap_blks_read) = 0 THEN 0
                ELSE round(
                    sum(heap_blks_hit)::numeric / 
                    (sum(heap_blks_hit) + sum(heap_blks_read)) * 100, 2
                )
            END
        FROM pg_statio_user_tables),
        'percentage'::text,
        NOW();
        
    RETURN QUERY
    SELECT 
        'database_size'::text,
        pg_database_size(current_database())::numeric,
        'bytes'::text,
        NOW();
        
    RETURN QUERY
    SELECT 
        'total_queries'::text,
        (SELECT sum(calls)::numeric FROM pg_stat_statements),
        'queries'::text,
        NOW();
END;
$$ LANGUAGE plpgsql;

-- Function to reset statistics
CREATE OR REPLACE FUNCTION reset_performance_stats()
RETURNS void AS $$
BEGIN
    -- Reset pg_stat_statements
    PERFORM pg_stat_statements_reset();
    
    -- Reset table and index statistics
    PERFORM pg_stat_reset();
    
    RAISE NOTICE 'Performance statistics have been reset';
END;
$$ LANGUAGE plpgsql;

-- ===============================
-- AUTOMATED MAINTENANCE QUERIES
-- ===============================

-- Query to identify tables that would benefit from clustering
CREATE OR REPLACE VIEW v_clustering_candidates AS
SELECT 
    schemaname,
    tablename,
    attname,
    correlation,
    CASE 
        WHEN abs(correlation) < 0.1 THEN 'HIGH_BENEFIT'
        WHEN abs(correlation) < 0.3 THEN 'MEDIUM_BENEFIT'
        WHEN abs(correlation) < 0.7 THEN 'LOW_BENEFIT'
        ELSE 'NO_BENEFIT'
    END as clustering_benefit
FROM pg_stats
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
    AND correlation IS NOT NULL
    AND abs(correlation) < 0.7
ORDER BY abs(correlation);

-- Query to identify potential partial index candidates
CREATE OR REPLACE VIEW v_partial_index_candidates AS
SELECT 
    schemaname,
    tablename,
    column_name,
    data_type,
    is_nullable,
    (SELECT count(*) FROM information_schema.table_constraints tc
     JOIN information_schema.key_column_usage kcu
     ON tc.constraint_name = kcu.constraint_name
     WHERE tc.table_schema = c.table_schema
     AND tc.table_name = c.table_name
     AND kcu.column_name = c.column_name
     AND tc.constraint_type = 'PRIMARY KEY') as is_pk,
    (SELECT count(*) FROM pg_indexes
     WHERE schemaname = c.table_schema
     AND tablename = c.table_name
     AND indexdef LIKE '%' || c.column_name || '%') as existing_indexes
FROM information_schema.columns c
WHERE c.table_schema NOT IN ('information_schema', 'pg_catalog')
    AND c.data_type IN ('boolean', 'character varying', 'text')
ORDER BY schemaname, tablename, column_name;

-- Create performance monitoring table for historical data
CREATE TABLE IF NOT EXISTS performance_metrics_history (
    id SERIAL PRIMARY KEY,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_unit TEXT,
    recorded_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- Index for time-series queries
CREATE INDEX IF NOT EXISTS idx_performance_metrics_history_time 
ON performance_metrics_history(recorded_at DESC);

CREATE INDEX IF NOT EXISTS idx_performance_metrics_history_metric 
ON performance_metrics_history(metric_name, recorded_at DESC);

COMMENT ON VIEW v_table_usage_stats IS 'Monitor table usage patterns and index effectiveness';
COMMENT ON VIEW v_slow_queries IS 'Identify slow queries for optimization (requires pg_stat_statements)';
COMMENT ON VIEW v_cache_hit_ratio IS 'Monitor buffer cache effectiveness';
COMMENT ON VIEW v_vacuum_needed IS 'Identify tables that need vacuuming';
COMMENT ON FUNCTION get_performance_snapshot() IS 'Get current performance metrics snapshot';
COMMENT ON TABLE performance_metrics_history IS 'Historical performance metrics for trend analysis';
